{"version":3,"sources":["../src/api/user_data_converter.ts"],"names":[],"mappings":"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","file":"user_data_converter.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as firestore from 'firestore';\n\nimport { DatabaseId } from '../core/database_info';\nimport { Timestamp } from '../core/timestamp';\nimport { DocumentKey } from '../model/document_key';\nimport { FieldValue, ObjectValue } from '../model/field_value';\nimport {\n  ArrayValue,\n  BlobValue,\n  BooleanValue,\n  DoubleValue,\n  GeoPointValue,\n  IntegerValue,\n  NullValue,\n  RefValue,\n  StringValue,\n  TimestampValue\n} from '../model/field_value';\nimport {\n  FieldMask,\n  FieldTransform,\n  Mutation,\n  PatchMutation,\n  Precondition,\n  ServerTimestampTransform,\n  SetMutation,\n  TransformMutation\n} from '../model/mutation';\nimport { FieldPath } from '../model/path';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { isPlainObject, valueDescription } from '../util/input_validation';\nimport { AnyJs, primitiveComparator } from '../util/misc';\nimport * as objUtils from '../util/obj';\nimport { Dict } from '../util/obj';\nimport { SortedMap } from '../util/sorted_map';\nimport * as typeUtils from '../util/types';\n\nimport { Blob } from './blob';\nimport {\n  FieldPath as ExternalFieldPath,\n  fromDotSeparatedString\n} from './field_path';\nimport {\n  DeleteFieldValueImpl,\n  FieldValueImpl,\n  ServerTimestampFieldValueImpl\n} from './field_value';\nimport { GeoPoint } from './geo_point';\n\nconst RESERVED_FIELD_REGEX = /^__.*__$/;\n\n/** The result of parsing document data (e.g. for a setData call). */\nexport class ParsedSetData {\n  constructor(\n    readonly data: ObjectValue,\n    readonly fieldMask: FieldMask | null,\n    readonly fieldTransforms: FieldTransform[]\n  ) {}\n\n  toMutations(key: DocumentKey, precondition: Precondition): Mutation[] {\n    const mutations = [] as Mutation[];\n    if (this.fieldMask !== null) {\n      mutations.push(\n        new PatchMutation(key, this.data, this.fieldMask, precondition)\n      );\n    } else {\n      mutations.push(new SetMutation(key, this.data, precondition));\n    }\n    if (this.fieldTransforms.length > 0) {\n      mutations.push(new TransformMutation(key, this.fieldTransforms));\n    }\n    return mutations;\n  }\n}\n\n/** The result of parsing \"update\" data (i.e. for an updateData call). */\nexport class ParsedUpdateData {\n  constructor(\n    readonly data: ObjectValue,\n    readonly fieldMask: FieldMask,\n    readonly fieldTransforms: FieldTransform[]\n  ) {}\n\n  toMutations(key: DocumentKey, precondition: Precondition): Mutation[] {\n    const mutations = [\n      new PatchMutation(key, this.data, this.fieldMask, precondition)\n    ] as Mutation[];\n    if (this.fieldTransforms.length > 0) {\n      mutations.push(new TransformMutation(key, this.fieldTransforms));\n    }\n    return mutations;\n  }\n}\n\n/*\n * Represents what type of API method provided the data being parsed; useful\n * for determining which error conditions apply during parsing and providing\n * better error messages.\n */\nenum UserDataSource {\n  Set,\n  Update,\n  MergeSet,\n  QueryValue // from a where clause or cursor bound\n}\n\nfunction isWrite(dataSource: UserDataSource) {\n  switch (dataSource) {\n    case UserDataSource.Set: // fall through\n    case UserDataSource.MergeSet: // fall through\n    case UserDataSource.Update:\n      return true;\n    case UserDataSource.QueryValue:\n      return false;\n    default:\n      throw fail(`Unexpected case for UserDataSource: ${dataSource}`);\n  }\n}\n\n/** A \"context\" object passed around while parsing user data. */\nclass ParseContext {\n  readonly fieldTransforms: FieldTransform[];\n  readonly fieldMask: FieldPath[];\n  /**\n   * Initializes a ParseContext with the given source and path.\n   *\n   * @param dataSource Indicates what kind of API method this data came from.\n   * @param methodName The name of the method the user called to create this\n   *     ParseContext.\n   * @param path A path within the object being parsed. This could be an empty\n   *     path (in which case the context represents the root of the data being\n   *     parsed), or a nonempty path (indicating the context represents a nested\n   *     location within the data).\n   * @param arrayElement Whether or not this context corresponds to an element\n   *     of an array.\n   * @param fieldTransforms A mutable list of field transforms encountered while\n   *     parsing the data.\n   * @param fieldMask A mutable list of field paths encountered while parsing\n   *     the data.\n   *\n   * TODO(b/34871131): We don't support array paths right now, so path can be\n   * null to indicate the context represents any location within an array (in\n   * which case certain features will not work and errors will be somewhat\n   * compromised).\n   */\n  constructor(\n    readonly dataSource: UserDataSource,\n    readonly methodName: string,\n    readonly path: FieldPath | null,\n    readonly arrayElement?: boolean,\n    fieldTransforms?: FieldTransform[],\n    fieldMask?: FieldPath[]\n  ) {\n    // Minor hack: If fieldTransforms is undefined, we assume this is an\n    // external call and we need to validate the entire path.\n    if (fieldTransforms === undefined) {\n      this.validatePath();\n    }\n    this.arrayElement = arrayElement !== undefined ? arrayElement : false;\n    this.fieldTransforms = fieldTransforms || [];\n    this.fieldMask = fieldMask || [];\n  }\n\n  childContextForField(field: string): ParseContext {\n    const childPath = this.path == null ? null : this.path.child(field);\n    const context = new ParseContext(\n      this.dataSource,\n      this.methodName,\n      childPath,\n      /*arrayElement=*/ false,\n      this.fieldTransforms,\n      this.fieldMask\n    );\n    context.validatePathSegment(field);\n    return context;\n  }\n\n  childContextForFieldPath(field: FieldPath): ParseContext {\n    const childPath = this.path == null ? null : this.path.child(field);\n    const context = new ParseContext(\n      this.dataSource,\n      this.methodName,\n      childPath,\n      /*arrayElement=*/ false,\n      this.fieldTransforms,\n      this.fieldMask\n    );\n    context.validatePath();\n    return context;\n  }\n\n  childContextForArray(index: number): ParseContext {\n    // TODO(b/34871131): We don't support array paths right now; so make path\n    // null.\n    return new ParseContext(\n      this.dataSource,\n      this.methodName,\n      /*path=*/ null,\n      /*arrayElement=*/ true,\n      this.fieldTransforms,\n      this.fieldMask\n    );\n  }\n\n  createError(reason: string): Error {\n    const fieldDescription =\n      this.path === null || this.path.isEmpty()\n        ? ''\n        : ` (found in field ${this.path.toString()})`;\n    return new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Function ${this.methodName}() called with invalid data. ` +\n        reason +\n        fieldDescription\n    );\n  }\n\n  private validatePath() {\n    // TODO(b/34871131): Remove null check once we have proper paths for fields\n    // within arrays.\n    if (this.path === null) {\n      return;\n    }\n    for (let i = 0; i < this.path.length; i++) {\n      this.validatePathSegment(this.path.get(i));\n    }\n  }\n\n  private validatePathSegment(segment: string) {\n    if (isWrite(this.dataSource) && RESERVED_FIELD_REGEX.test(segment)) {\n      throw this.createError('Document fields cannot begin and end with __');\n    }\n  }\n\n  private isWrite(): boolean {\n    return (\n      this.dataSource === UserDataSource.Set ||\n      this.dataSource === UserDataSource.Update\n    );\n  }\n}\n/**\n * An interface that allows arbitrary pre-converting of user data. This\n * abstraction allows for, e.g.:\n *  * The public API to convert DocumentReference objects to DocRef objects,\n *    avoiding a circular dependency between user_data_converter.ts and\n *    database.ts\n *  * Tests to convert test-only sentinels (e.g. '<DELETE>') into types\n *    compatible with UserDataConverter.\n *\n * Returns the converted value (can return back the input to act as a no-op).\n *\n * It can also throw an Error which will be wrapped into a friendly message.\n */\nexport type DataPreConverter = (input: AnyJs) => AnyJs;\n\n/**\n * A placeholder object for DocumentReferences in this file, in order to\n * avoid a circular dependency. See the comments for `DataPreConverter` for\n * the full context.\n */\nexport class DocumentKeyReference {\n  constructor(public databaseId: DatabaseId, public key: DocumentKey) {}\n}\n\n/**\n * Helper for parsing raw user input (provided via the API) into internal model\n * classes.\n */\nexport class UserDataConverter {\n  constructor(private preConverter: DataPreConverter) {}\n\n  /** Parse document data from a non-merge set() call.*/\n  parseSetData(methodName: string, input: AnyJs): ParsedSetData {\n    const context = new ParseContext(\n      UserDataSource.Set,\n      methodName,\n      FieldPath.EMPTY_PATH\n    );\n    validatePlainObject('Data must be an object, but it was:', context, input);\n\n    let updateData = this.parseData(input, context);\n\n    return new ParsedSetData(\n      updateData as ObjectValue,\n      /* fieldMask= */ null,\n      context.fieldTransforms\n    );\n  }\n\n  /** Parse document data from a set() call with '{merge:true}'. */\n  parseMergeData(methodName: string, input: AnyJs): ParsedSetData {\n    const context = new ParseContext(\n      UserDataSource.MergeSet,\n      methodName,\n      FieldPath.EMPTY_PATH\n    );\n    validatePlainObject('Data must be an object, but it was:', context, input);\n\n    let updateData = this.parseData(input, context);\n    const fieldMask = new FieldMask(context.fieldMask);\n    return new ParsedSetData(\n      updateData as ObjectValue,\n      fieldMask,\n      context.fieldTransforms\n    );\n  }\n\n  /** Parse update data from an update() call. */\n  parseUpdateData(methodName: string, input: AnyJs): ParsedUpdateData {\n    const context = new ParseContext(\n      UserDataSource.Update,\n      methodName,\n      FieldPath.EMPTY_PATH\n    );\n    validatePlainObject('Data must be an object, but it was:', context, input);\n\n    const fieldMaskPaths = [] as FieldPath[];\n    let updateData = ObjectValue.EMPTY;\n    objUtils.forEach(input as Dict<AnyJs>, (key, value) => {\n      const path = fieldPathFromDotSeparatedString(methodName, key);\n\n      const childContext = context.childContextForFieldPath(path);\n      value = this.runPreConverter(value, childContext);\n      if (value instanceof DeleteFieldValueImpl) {\n        // Add it to the field mask, but don't add anything to updateData.\n        fieldMaskPaths.push(path);\n      } else {\n        const parsedValue = this.parseData(value, childContext);\n        if (parsedValue != null) {\n          fieldMaskPaths.push(path);\n          updateData = updateData.set(path, parsedValue);\n        }\n      }\n    });\n\n    const mask = new FieldMask(fieldMaskPaths);\n    return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\n  }\n\n  /** Parse update data from a list of field/value arguments. */\n  parseUpdateVarargs(\n    methodName: string,\n    field: string | ExternalFieldPath,\n    value: AnyJs,\n    moreFieldsAndValues: AnyJs[]\n  ): ParsedUpdateData {\n    const context = new ParseContext(\n      UserDataSource.Update,\n      methodName,\n      FieldPath.EMPTY_PATH\n    );\n    const keys = [fieldPathFromArgument(methodName, field)];\n    const values = [value];\n\n    if (moreFieldsAndValues.length % 2 !== 0) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Function ${methodName}() needs to be called with an even number ` +\n          'of arguments that alternate between field names and values.'\n      );\n    }\n\n    for (let i = 0; i < moreFieldsAndValues.length; i += 2) {\n      keys.push(\n        fieldPathFromArgument(methodName, moreFieldsAndValues[i] as\n          | string\n          | ExternalFieldPath)\n      );\n      values.push(moreFieldsAndValues[i + 1]);\n    }\n\n    const fieldMaskPaths = [] as FieldPath[];\n    let updateData = ObjectValue.EMPTY;\n\n    for (let i = 0; i < keys.length; ++i) {\n      const path = keys[i];\n      const childContext = context.childContextForFieldPath(path);\n      const value = this.runPreConverter(values[i], childContext);\n      if (value instanceof DeleteFieldValueImpl) {\n        // Add it to the field mask, but don't add anything to updateData.\n        fieldMaskPaths.push(path);\n      } else {\n        const parsedValue = this.parseData(value, childContext);\n        if (parsedValue != null) {\n          fieldMaskPaths.push(path);\n          updateData = updateData.set(path, parsedValue);\n        }\n      }\n    }\n\n    const mask = new FieldMask(fieldMaskPaths);\n    return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\n  }\n\n  /**\n   * Parse a \"query value\" (e.g. value in a where filter or a value in a cursor\n   * bound).\n   */\n  parseQueryValue(methodName: string, input: AnyJs): FieldValue {\n    const context = new ParseContext(\n      UserDataSource.QueryValue,\n      methodName,\n      FieldPath.EMPTY_PATH\n    );\n    const parsed = this.parseData(input, context);\n    assert(parsed != null, 'Parsed data should not be null.');\n    assert(\n      context.fieldTransforms.length === 0,\n      'Field transforms should have been disallowed.'\n    );\n    return parsed!;\n  }\n\n  /** Sends data through this.preConverter, handling any thrown errors. */\n  private runPreConverter(input: AnyJs, context: ParseContext): AnyJs {\n    try {\n      return this.preConverter(input);\n    } catch (e) {\n      const message = errorMessage(e);\n      throw context.createError(message);\n    }\n  }\n\n  /**\n   * Internal helper for parsing user data.\n   *\n   * @param input Data to be parsed.\n   * @param context A context object representing the current path being parsed,\n   * the source of the data being parsed, etc.\n   * @return The parsed value, or null if the value was a FieldValue sentinel\n   * that should not be included in the resulting parsed data.\n   */\n  private parseData(input: AnyJs, context: ParseContext): FieldValue | null {\n    input = this.runPreConverter(input, context);\n    if (input instanceof Array) {\n      // TODO(b/34871131): Include the path containing the array in the error\n      // message.\n      if (context.arrayElement) {\n        throw context.createError('Nested arrays are not supported');\n      }\n      // If context.path is null we are already inside an array and we don't\n      // support field mask paths more granular than the top-level array.\n      if (context.path) {\n        context.fieldMask.push(context.path);\n      }\n      return this.parseArray(input as AnyJs[], context);\n    } else if (looksLikeJsonObject(input)) {\n      validatePlainObject('Unsupported field value:', context, input);\n      return this.parseObject(input as Dict<AnyJs>, context);\n    } else {\n      // If context.path is null, we are inside an array and we should have\n      // already added the root of the array to the field mask.\n      if (context.path) {\n        context.fieldMask.push(context.path);\n      }\n      return this.parseScalarValue(input, context);\n    }\n  }\n\n  private parseArray(array: AnyJs[], context: ParseContext): FieldValue {\n    const result = [] as FieldValue[];\n    let entryIndex = 0;\n    for (const entry of array) {\n      let parsedEntry = this.parseData(\n        entry,\n        context.childContextForArray(entryIndex)\n      );\n      if (parsedEntry == null) {\n        // Just include nulls in the array for fields being replaced with a\n        // sentinel.\n        parsedEntry = NullValue.INSTANCE;\n      }\n      result.push(parsedEntry);\n      entryIndex++;\n    }\n    return new ArrayValue(result);\n  }\n\n  private parseObject(obj: Dict<AnyJs>, context: ParseContext): FieldValue {\n    let result = new SortedMap<string, FieldValue>(primitiveComparator);\n    objUtils.forEach(obj, (key: string, val: AnyJs) => {\n      const parsedValue = this.parseData(\n        val,\n        context.childContextForField(key)\n      );\n      if (parsedValue != null) {\n        result = result.insert(key, parsedValue);\n      }\n    });\n    return new ObjectValue(result);\n  }\n\n  /**\n   * Helper to parse a scalar value (i.e. not an Object or Array)\n   *\n   * @return The parsed value, or null if the value was a FieldValue sentinel\n   * that should not be included in the resulting parsed data.\n   */\n  private parseScalarValue(\n    value: AnyJs,\n    context: ParseContext\n  ): FieldValue | null {\n    if (value === null) {\n      return NullValue.INSTANCE;\n    } else if (typeof value === 'number') {\n      if (typeUtils.isSafeInteger(value)) {\n        return new IntegerValue(value);\n      } else {\n        return new DoubleValue(value);\n      }\n    } else if (typeof value === 'boolean') {\n      return BooleanValue.of(value);\n    } else if (typeof value === 'string') {\n      return new StringValue(value);\n    } else if (value instanceof Date) {\n      return new TimestampValue(Timestamp.fromDate(value));\n    } else if (value instanceof GeoPoint) {\n      return new GeoPointValue(value);\n    } else if (value instanceof Blob) {\n      return new BlobValue(value);\n    } else if (value instanceof DocumentKeyReference) {\n      return new RefValue(value.databaseId, value.key);\n    } else if (value instanceof FieldValueImpl) {\n      if (value instanceof DeleteFieldValueImpl) {\n        if (context.dataSource == UserDataSource.MergeSet) {\n          return null;\n        } else if (context.dataSource === UserDataSource.Update) {\n          assert(\n            context.path == null || context.path.length > 0,\n            'FieldValue.delete() at the top level should have already' +\n              ' been handled.'\n          );\n          throw context.createError(\n            'FieldValue.delete() can only appear at the top level ' +\n              'of your update data'\n          );\n        } else {\n          // We shouldn't encounter delete sentinels for queries or non-merge set() calls.\n          throw context.createError(\n            'FieldValue.delete() can only be used with update() and set() with {merge:true}'\n          );\n        }\n      } else if (value instanceof ServerTimestampFieldValueImpl) {\n        if (!isWrite(context.dataSource)) {\n          throw context.createError(\n            'FieldValue.serverTimestamp() can only be used with set()' +\n              ' and update()'\n          );\n        }\n        if (context.path === null) {\n          throw context.createError(\n            'FieldValue.serverTimestamp() is not currently' +\n              ' supported inside arrays'\n          );\n        }\n        context.fieldTransforms.push(\n          new FieldTransform(context.path, ServerTimestampTransform.instance)\n        );\n\n        // Return null so this value is omitted from the parsed result.\n        return null;\n      } else {\n        return fail('Unknown FieldValue type: ' + value);\n      }\n    } else {\n      throw context.createError(\n        `Unsupported field value: ${valueDescription(value)}`\n      );\n    }\n  }\n}\n\n/**\n * Checks whether an object looks like a JSON object that should be converted\n * into a struct. Normal class/prototype instances are considered to look like\n * JSON objects since they should be converted to a struct value. Arrays, Dates,\n * GeoPoints, etc. are not considered to look like JSON objects since they map\n * to specific FieldValue types other than ObjectValue.\n */\nfunction looksLikeJsonObject(input: AnyJs): boolean {\n  return (\n    typeof input === 'object' &&\n    input !== null &&\n    !(input instanceof Array) &&\n    !(input instanceof Date) &&\n    !(input instanceof GeoPoint) &&\n    !(input instanceof Blob) &&\n    !(input instanceof DocumentKeyReference) &&\n    !(input instanceof FieldValueImpl)\n  );\n}\n\nfunction validatePlainObject(\n  message: string,\n  context: ParseContext,\n  input: AnyJs\n) {\n  if (!looksLikeJsonObject(input) || !isPlainObject(input)) {\n    const description = valueDescription(input);\n    if (description === 'an object') {\n      // Massage the error if it was an object.\n      throw context.createError(message + ' a custom object');\n    } else {\n      throw context.createError(message + ' ' + description);\n    }\n  }\n}\n\n/**\n * Helper that calls fromDotSeparatedString() but wraps any error thrown.\n */\nexport function fieldPathFromArgument(\n  methodName: string,\n  path: string | ExternalFieldPath\n): FieldPath {\n  if (path instanceof ExternalFieldPath) {\n    return path._internalPath;\n  } else if (typeof path === 'string') {\n    return fieldPathFromDotSeparatedString(methodName, path);\n  } else {\n    const message = 'Field path arguments must be of type string or FieldPath.';\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Function ${methodName}() called with invalid data. ${message}`\n    );\n  }\n}\n\n/**\n * Wraps fromDotSeparatedString with an error message about the method that\n * was thrown.\n * @param methodName The publicly visible method name\n * @param path The dot-separated string form of a field path which will be split\n * on dots.\n */\nfunction fieldPathFromDotSeparatedString(\n  methodName: string,\n  path: string\n): FieldPath {\n  try {\n    return fromDotSeparatedString(path)._internalPath;\n  } catch (e) {\n    const message = errorMessage(e);\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Function ${methodName}() called with invalid data. ${message}`\n    );\n  }\n}\n\n/**\n * Extracts the message from a caught exception, which should be an Error object\n * though JS doesn't guarantee that.\n */\nfunction errorMessage(error: Error | object): string {\n  return error instanceof Error ? error.message : error.toString();\n}\n"]}