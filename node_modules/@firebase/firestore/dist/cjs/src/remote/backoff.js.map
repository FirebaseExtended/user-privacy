{"version":3,"sources":["../src/remote/backoff.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;GAcG;;AAEH,iCAAmC;AACnC,2CAA2C;AAE3C,IAAM,OAAO,GAAG,oBAAoB,CAAC;AAErC;;;;;;;;GAQG;AACH;IAGE;QACE;;;;WAIG;QACc,cAAsB;QACvC;;;WAGG;QACc,aAAqB;QACtC;;;;WAIG;QACc,UAAkB;QAXlB,mBAAc,GAAd,cAAc,CAAQ;QAKtB,kBAAa,GAAb,aAAa,CAAQ;QAMrB,eAAU,GAAV,UAAU,CAAQ;QAEnC,IAAI,CAAC,KAAK,EAAE,CAAC;IACf,CAAC;IAED;;;;;;OAMG;IACH,kCAAK,GAAL;QACE,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC;IACzB,CAAC;IAED;;;OAGG;IACH,uCAAU,GAAV;QACE,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,UAAU,CAAC;IACvC,CAAC;IAED;;;OAGG;IACH,2CAAc,GAAd;QACE,IAAM,GAAG,GAAG,IAAI,kBAAQ,EAAQ,CAAC;QAEjC,sEAAsE;QACtE,oBAAoB;QACpB,IAAM,iBAAiB,GAAG,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;QACpE,EAAE,CAAC,CAAC,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC,CAAC,CAAC;YAC3B,GAAG,CAAC,KAAK,CACP,OAAO,EACP,qBAAmB,iBAAiB,SAAM;iBACxC,kBAAgB,IAAI,CAAC,aAAa,SAAM,CAAA,CAC3C,CAAC;QACJ,CAAC;QACD,UAAU,CAAC;YACT,GAAG,CAAC,OAAO,EAAE,CAAC;QAChB,CAAC,EAAE,iBAAiB,CAAC,CAAC;QAEtB,uEAAuE;QACvE,UAAU;QACV,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,aAAa,CAAC;QACzC,EAAE,CAAC,CAAC,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;YAC7C,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,cAAc,CAAC;QAC3C,CAAC;QACD,EAAE,CAAC,CAAC,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;YACzC,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,UAAU,CAAC;QACvC,CAAC;QAED,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC;IACrB,CAAC;IAED,8EAA8E;IACtE,0CAAa,GAArB;QACE,MAAM,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,GAAG,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC;IACpD,CAAC;IACH,yBAAC;AAAD,CAlFA,AAkFC,IAAA;AAlFY,gDAAkB","file":"backoff.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as log from '../util/log';\nimport { Deferred } from '../util/promise';\n\nconst LOG_TAG = 'ExponentialBackoff';\n\n/**\n * A helper for running delayed tasks following an exponential backoff curve\n * between attempts.\n *\n * Each delay is made up of a \"base\" delay which follows the exponential\n * backoff curve, and a +/- 50% \"jitter\" that is calculated and added to the\n * base delay. This prevents clients from accidentally synchronizing their\n * delays causing spikes of load to the backend.\n */\nexport class ExponentialBackoff {\n  private currentBaseMs: number;\n\n  constructor(\n    /**\n     * The initial delay (used as the base delay on the first retry attempt).\n     * Note that jitter will still be applied, so the actual delay could be as\n     * little as 0.5*initialDelayMs.\n     */\n    private readonly initialDelayMs: number,\n    /**\n     * The multiplier to use to determine the extended base delay after each\n     * attempt.\n     */\n    private readonly backoffFactor: number,\n    /**\n     * The maximum base delay after which no further backoff is performed.\n     * Note that jitter will still be applied, so the actual delay could be as\n     * much as 1.5*maxDelayMs.\n     */\n    private readonly maxDelayMs: number\n  ) {\n    this.reset();\n  }\n\n  /**\n   * Resets the backoff delay.\n   *\n   * The very next backoffAndWait() will have no delay. If it is called again\n   * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and\n   * subsequent ones will increase according to the backoffFactor.\n   */\n  reset(): void {\n    this.currentBaseMs = 0;\n  }\n\n  /**\n   * Resets the backoff delay to the maximum delay (e.g. for use after a\n   * RESOURCE_EXHAUSTED error).\n   */\n  resetToMax(): void {\n    this.currentBaseMs = this.maxDelayMs;\n  }\n\n  /**\n   * Returns a promise that resolves after currentDelayMs, and increases the\n   * delay for any subsequent attempts.\n   */\n  backoffAndWait(): Promise<void> {\n    const def = new Deferred<void>();\n\n    // First schedule using the current base (which may be 0 and should be\n    // honored as such).\n    const delayWithJitterMs = this.currentBaseMs + this.jitterDelayMs();\n    if (this.currentBaseMs > 0) {\n      log.debug(\n        LOG_TAG,\n        `Backing off for ${delayWithJitterMs} ms ` +\n          `(base delay: ${this.currentBaseMs} ms)`\n      );\n    }\n    setTimeout(() => {\n      def.resolve();\n    }, delayWithJitterMs);\n\n    // Apply backoff factor to determine next delay and ensure it is within\n    // bounds.\n    this.currentBaseMs *= this.backoffFactor;\n    if (this.currentBaseMs < this.initialDelayMs) {\n      this.currentBaseMs = this.initialDelayMs;\n    }\n    if (this.currentBaseMs > this.maxDelayMs) {\n      this.currentBaseMs = this.maxDelayMs;\n    }\n\n    return def.promise;\n  }\n\n  /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */\n  private jitterDelayMs(): number {\n    return (Math.random() - 0.5) * this.currentBaseMs;\n  }\n}\n"]}