{"version":3,"sources":["../src/api/credentials.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;GAcG;AAEH,OAAO,EAAE,IAAI,EAAE,MAAM,cAAc,CAAC;AACpC,OAAO,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,gBAAgB,CAAC;AAC9C,OAAO,EAAE,IAAI,EAAE,cAAc,EAAE,MAAM,eAAe,CAAC;AAsCrD;IAGE,oBAAY,KAAa,EAAS,IAAU;QAAV,SAAI,GAAJ,IAAI,CAAM;QAF5C,SAAI,GAAG,OAAoB,CAAC;QAG1B,IAAI,CAAC,WAAW,GAAG,EAAE,aAAa,EAAE,YAAU,KAAO,EAAE,CAAC;IAC1D,CAAC;IACH,iBAAC;AAAD,CANA,AAMC,IAAA;;AA4BD,+DAA+D;AAC/D;IAQE;QAPA;;;;WAIG;QACK,iBAAY,GAAwB,IAAI,CAAC;IAElC,CAAC;IAEhB,2CAAQ,GAAR,UAAS,YAAqB;QAC5B,MAAM,CAAC,OAAO,CAAC,OAAO,CAAe,IAAI,CAAC,CAAC;IAC7C,CAAC;IAED,wDAAqB,GAArB,UAAsB,QAAsB;QAC1C,MAAM,CAAC,CAAC,IAAI,CAAC,YAAY,EAAE,6CAA6C,CAAC,CAAC;QAC1E,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC;QAC7B,0BAA0B;QAC1B,QAAQ,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;IACjC,CAAC;IAED,2DAAwB,GAAxB;QACE,MAAM,CACJ,IAAI,CAAC,YAAY,KAAK,IAAI,EAC1B,wDAAwD,CACzD,CAAC;QACF,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;IAC3B,CAAC;IACH,+BAAC;AAAD,CA5BA,AA4BC,IAAA;;AAED;IAmBE,qCAA6B,GAAgB;QAA7C,iBAkBC;QAlB4B,QAAG,GAAH,GAAG,CAAa;QAlB7C;;;WAGG;QACK,kBAAa,GAA4C,IAAI,CAAC;QAKtE;;;WAGG;QACK,gBAAW,GAAG,CAAC,CAAC;QAExB,iEAAiE;QACzD,iBAAY,GAAwB,IAAI,CAAC;QAG/C,2EAA2E;QAC3E,4BAA4B;QAC5B,IAAI,CAAC,aAAa,GAAG;YACnB,IAAM,OAAO,GAAG,KAAI,CAAC,OAAO,EAAE,CAAC;YAC/B,EAAE,CAAC,CAAC,CAAC,KAAI,CAAC,WAAW,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,KAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;gBAC3D,KAAI,CAAC,WAAW,GAAG,OAAO,CAAC;gBAC3B,KAAI,CAAC,WAAW,EAAE,CAAC;gBACnB,EAAE,CAAC,CAAC,KAAI,CAAC,YAAY,CAAC,CAAC,CAAC;oBACtB,KAAI,CAAC,YAAY,CAAC,KAAI,CAAC,WAAW,CAAC,CAAC;gBACtC,CAAC;YACH,CAAC;QACH,CAAC,CAAC;QAEF,IAAI,CAAC,WAAW,GAAG,CAAC,CAAC;QAErB,wDAAwD;QACxD,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,oBAAoB,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;IAC7D,CAAC;IAED,8CAAQ,GAAR,UAAS,YAAqB;QAA9B,iBA+BC;QA9BC,MAAM,CACJ,IAAI,CAAC,aAAa,IAAI,IAAI,EAC1B,mDAAmD,CACpD,CAAC;QAEF,4EAA4E;QAC5E,2EAA2E;QAC3E,kBAAkB;QAClB,IAAM,kBAAkB,GAAG,IAAI,CAAC,WAAW,CAAC;QAC5C,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC,IAAI,CAAC,UAAA,SAAS;YAC5D,kEAAkE;YAClE,mEAAmE;YACnE,2BAA2B;YAC3B,EAAE,CAAC,CAAC,KAAI,CAAC,WAAW,KAAK,kBAAkB,CAAC,CAAC,CAAC;gBAC5C,MAAM,IAAI,cAAc,CACtB,IAAI,CAAC,OAAO,EACZ,qCAAqC,CACtC,CAAC;YACJ,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;oBACd,MAAM,CACJ,OAAO,SAAS,CAAC,WAAW,KAAK,QAAQ,EACzC,6CAA6C,GAAG,SAAS,CAC1D,CAAC;oBACF,MAAM,CAAC,IAAI,UAAU,CAAC,SAAS,CAAC,WAAW,EAAE,KAAI,CAAC,WAAW,CAAC,CAAC;gBACjE,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,MAAM,CAAC,IAAI,CAAC;gBACd,CAAC;YACH,CAAC;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED,2DAAqB,GAArB,UAAsB,QAAsB;QAC1C,MAAM,CAAC,CAAC,IAAI,CAAC,YAAY,EAAE,6CAA6C,CAAC,CAAC;QAC1E,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC;QAE7B,mEAAmE;QACnE,EAAE,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;YACrB,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAC7B,CAAC;IACH,CAAC;IAED,8DAAwB,GAAxB;QACE,MAAM,CACJ,IAAI,CAAC,aAAa,IAAI,IAAI,EAC1B,yCAAyC,CAC1C,CAAC;QACF,MAAM,CACJ,IAAI,CAAC,YAAY,KAAK,IAAI,EAC1B,+DAA+D,CAChE,CAAC;QACF,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,uBAAuB,CAAC,IAAI,CAAC,aAAc,CAAC,CAAC;QAC/D,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;QAC1B,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;IAC3B,CAAC;IAEO,6CAAO,GAAf;QACE,2EAA2E;QAC3E,EAAE,CAAC,CAAC,OAAO,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,MAAM,KAAK,UAAU,CAAC,CAAC,CAAC;YACnD,IAAI,CACF,6DAA6D;gBAC3D,wBAAwB,CAC3B,CAAC;QACJ,CAAC;QACD,IAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC;QAC9C,MAAM,CACJ,UAAU,KAAK,IAAI,IAAI,OAAO,UAAU,KAAK,QAAQ,EACrD,wBAAwB,GAAG,UAAU,CACtC,CAAC;QACF,MAAM,CAAC,IAAI,IAAI,CAAC,UAAU,CAAC,CAAC;IAC9B,CAAC;IACH,kCAAC;AAAD,CA/GA,AA+GC,IAAA;;AAMD;;;;;;GAMG;AACH;IAIE,yBAAoB,IAAU,EAAU,YAAoB;QAAxC,SAAI,GAAJ,IAAI,CAAM;QAAU,iBAAY,GAAZ,YAAY,CAAQ;QAH5D,SAAI,GAAG,YAAyB,CAAC;QACjC,SAAI,GAAG,IAAI,CAAC,WAAW,CAAC;QAGtB,MAAM,CACJ,IAAI,CAAC,IAAI;YACP,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC;YACjB,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,iCAAiC,CAAC,EACtD,2BAA2B,CAC5B,CAAC;IACJ,CAAC;IAED,sBAAI,wCAAW;aAAf;YACE,MAAM,CAAC;gBACL,aAAa,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,iCAAiC,CAAC,CAAC,EAAE,CAAC;gBACvE,iBAAiB,EAAE,IAAI,CAAC,YAAY;aACrC,CAAC;QACJ,CAAC;;;OAAA;IACH,sBAAC;AAAD,CAnBA,AAmBC,IAAA;;AAED;;;;GAIG;AACH;IACE,uCAAoB,IAAU,EAAU,YAAoB;QAAxC,SAAI,GAAJ,IAAI,CAAM;QAAU,iBAAY,GAAZ,YAAY,CAAQ;QAC1D,MAAM,CACJ,IAAI,CAAC,IAAI;YACP,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC;YACjB,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,iCAAiC,CAAC,EACtD,2BAA2B,CAC5B,CAAC;IACJ,CAAC;IAED,gDAAQ,GAAR,UAAS,YAAqB;QAC5B,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,eAAe,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC;IAC5E,CAAC;IAED,+DAA+D;IAC/D,6DAA6D;IAC7D,6DAAqB,GAArB,UAAsB,QAAsB;QAC1C,yBAAyB;QACzB,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;IAC7B,CAAC;IAED,gEAAwB,GAAxB,cAAkC,CAAC;IACrC,oCAAC;AAAD,CAtBA,AAsBC,IAAA;;AAED;;;GAGG;AACH,MAAM,kCAAkC,WAAiC;IACvE,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;QACjB,MAAM,CAAC,IAAI,wBAAwB,EAAE,CAAC;IACxC,CAAC;IAED,MAAM,CAAC,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC;QACzB,KAAK,MAAM;YACT,MAAM,CAAC,IAAI,6BAA6B,CACtC,WAAW,CAAC,MAAM,EAClB,WAAW,CAAC,YAAY,IAAI,GAAG,CAChC,CAAC;QAEJ,KAAK,UAAU;YACb,MAAM,CAAC,WAAW,CAAC,MAAM,CAAC;QAE5B;YACE,MAAM,IAAI,cAAc,CACtB,IAAI,CAAC,gBAAgB,EACrB,+DAA+D,CAChE,CAAC;IACN,CAAC;AACH,CAAC","file":"credentials.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { User } from '../auth/user';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { AnyJs } from '../util/misc';\nimport { FirebaseApp } from '@firebase/app';\n\n// TODO(mikelehen): This should be split into multiple files and probably\n// moved to an auth/ folder to match other platforms.\n\nexport interface FirstPartyCredentialsSettings {\n  type: 'gapi';\n  client: Gapi;\n  sessionIndex: string;\n}\n\nexport interface ProviderCredentialsSettings {\n  type: 'provider';\n  client: CredentialsProvider;\n}\n\n/** Settings for private credentials */\nexport type CredentialsSettings =\n  | FirstPartyCredentialsSettings\n  | ProviderCredentialsSettings;\n\nexport type TokenType = 'OAuth' | 'FirstParty';\nexport interface Token {\n  /** Type of token. */\n  type: TokenType;\n\n  /**\n   * The user with which the token is associated (used for persisting user\n   * state on disk, etc.).\n   */\n  user: User;\n\n  /** Extra header values to be passed along with a request */\n  authHeaders: { [header: string]: string };\n}\n\nexport class OAuthToken implements Token {\n  type = 'OAuth' as TokenType;\n  authHeaders: { [header: string]: string };\n  constructor(value: string, public user: User) {\n    this.authHeaders = { Authorization: `Bearer ${value}` };\n  }\n}\n\n/**\n * A Listener for user change events.\n */\nexport type UserListener = (user: User) => void;\n\n/**\n * Provides methods for getting the uid and token for the current user and\n * listening for changes.\n */\nexport interface CredentialsProvider {\n  /**\n   * Requests a token for the current user, optionally forcing a refreshed\n   * token to be fetched.\n   */\n  getToken(forceRefresh: boolean): Promise<Token | null>;\n\n  /**\n   * Specifies a listener to be notified of user changes (sign-in / sign-out).\n   * It immediately called once with the initial user.\n   */\n  setUserChangeListener(listener: UserListener): void;\n\n  /** Removes the previously-set user change listener. */\n  removeUserChangeListener(): void;\n}\n\n/** A CredentialsProvider that always yields an empty token. */\nexport class EmptyCredentialsProvider implements CredentialsProvider {\n  /**\n   * Stores the User listener registered with setUserChangeListener()\n   * This isn't actually necessary since the UID never changes, but we use this\n   * to verify the listen contract is adhered to in tests.\n   */\n  private userListener: UserListener | null = null;\n\n  constructor() {}\n\n  getToken(forceRefresh: boolean): Promise<Token | null> {\n    return Promise.resolve<Token | null>(null);\n  }\n\n  setUserChangeListener(listener: UserListener): void {\n    assert(!this.userListener, 'Can only call setUserChangeListener() once.');\n    this.userListener = listener;\n    // Fire with initial user.\n    listener(User.UNAUTHENTICATED);\n  }\n\n  removeUserChangeListener(): void {\n    assert(\n      this.userListener !== null,\n      'removeUserChangeListener() when no listener registered'\n    );\n    this.userListener = null;\n  }\n}\n\nexport class FirebaseCredentialsProvider implements CredentialsProvider {\n  /**\n   * The auth token listener registered with FirebaseApp, retained here so we\n   * can unregister it.\n   */\n  private tokenListener: ((token: string | null) => void) | null = null;\n\n  /** Tracks the current User. */\n  private currentUser: User;\n\n  /**\n   * Counter used to detect if the user changed while a getToken request was\n   * outstanding.\n   */\n  private userCounter = 0;\n\n  /** The User listener registered with setUserChangeListener(). */\n  private userListener: UserListener | null = null;\n\n  constructor(private readonly app: FirebaseApp) {\n    // We listen for token changes but all we really care about is knowing when\n    // the uid may have changed.\n    this.tokenListener = () => {\n      const newUser = this.getUser();\n      if (!this.currentUser || !newUser.equals(this.currentUser)) {\n        this.currentUser = newUser;\n        this.userCounter++;\n        if (this.userListener) {\n          this.userListener(this.currentUser);\n        }\n      }\n    };\n\n    this.userCounter = 0;\n\n    // Will fire at least once where we set this.currentUser\n    this.app.INTERNAL.addAuthTokenListener(this.tokenListener);\n  }\n\n  getToken(forceRefresh: boolean): Promise<Token | null> {\n    assert(\n      this.tokenListener != null,\n      'getToken cannot be called after listener removed.'\n    );\n\n    // Take note of the current value of the userCounter so that this method can\n    // fail (with an ABORTED error) if there is a user change while the request\n    // is outstanding.\n    const initialUserCounter = this.userCounter;\n    return this.app.INTERNAL.getToken(forceRefresh).then(tokenData => {\n      // Cancel the request since the user changed while the request was\n      // outstanding so the response is likely for a previous user (which\n      // user, we can't be sure).\n      if (this.userCounter !== initialUserCounter) {\n        throw new FirestoreError(\n          Code.ABORTED,\n          'getToken aborted due to uid change.'\n        );\n      } else {\n        if (tokenData) {\n          assert(\n            typeof tokenData.accessToken === 'string',\n            'Invalid tokenData returned from getToken():' + tokenData\n          );\n          return new OAuthToken(tokenData.accessToken, this.currentUser);\n        } else {\n          return null;\n        }\n      }\n    });\n  }\n\n  setUserChangeListener(listener: UserListener): void {\n    assert(!this.userListener, 'Can only call setUserChangeListener() once.');\n    this.userListener = listener;\n\n    // Fire the initial event, but only if we received the initial user\n    if (this.currentUser) {\n      listener(this.currentUser);\n    }\n  }\n\n  removeUserChangeListener(): void {\n    assert(\n      this.tokenListener != null,\n      'removeUserChangeListener() called twice'\n    );\n    assert(\n      this.userListener !== null,\n      'removeUserChangeListener() called when no listener registered'\n    );\n    this.app.INTERNAL.removeAuthTokenListener(this.tokenListener!);\n    this.tokenListener = null;\n    this.userListener = null;\n  }\n\n  private getUser(): User {\n    // TODO(mikelehen): Remove this check once we're shipping with firebase.js.\n    if (typeof this.app.INTERNAL.getUid !== 'function') {\n      fail(\n        'This version of the Firestore SDK requires at least version' +\n          ' 3.7.0 of firebase.js.'\n      );\n    }\n    const currentUid = this.app.INTERNAL.getUid();\n    assert(\n      currentUid === null || typeof currentUid === 'string',\n      'Received invalid UID: ' + currentUid\n    );\n    return new User(currentUid);\n  }\n}\n\n// TODO(b/32935141): Ideally gapi type would be declared as an extern\n// tslint:disable-next-line:no-any\nexport type Gapi = any;\n\n/*\n * FirstPartyToken provides a fresh token each time its value\n * is requested, because if the token is too old, requests will be rejected.\n * TODO(b/33147818) this implementation violates the current assumption that\n * tokens are immutable.  We need to either revisit this assumption or come\n * up with some way for FPA to use the listen/unlisten interface.\n */\nexport class FirstPartyToken implements Token {\n  type = 'FirstParty' as TokenType;\n  user = User.FIRST_PARTY;\n\n  constructor(private gapi: Gapi, private sessionIndex: string) {\n    assert(\n      this.gapi &&\n        this.gapi['auth'] &&\n        this.gapi['auth']['getAuthHeaderValueForFirstParty'],\n      'unexpected gapi interface'\n    );\n  }\n\n  get authHeaders(): { [header: string]: string } {\n    return {\n      Authorization: this.gapi['auth']['getAuthHeaderValueForFirstParty']([]),\n      'X-Goog-AuthUser': this.sessionIndex\n    };\n  }\n}\n\n/*\n * Provides user credentials required for the Firestore JavaScript SDK\n * to authenticate the user, using technique that is only available\n * to applications hosted by Google.\n */\nexport class FirstPartyCredentialsProvider implements CredentialsProvider {\n  constructor(private gapi: Gapi, private sessionIndex: string) {\n    assert(\n      this.gapi &&\n        this.gapi['auth'] &&\n        this.gapi['auth']['getAuthHeaderValueForFirstParty'],\n      'unexpected gapi interface'\n    );\n  }\n\n  getToken(forceRefresh: boolean): Promise<Token | null> {\n    return Promise.resolve(new FirstPartyToken(this.gapi, this.sessionIndex));\n  }\n\n  // TODO(33108925): can someone switch users w/o a page refresh?\n  // TODO(33110621): need to understand token/session lifecycle\n  setUserChangeListener(listener: UserListener): void {\n    // Fire with initial uid.\n    listener(User.FIRST_PARTY);\n  }\n\n  removeUserChangeListener(): void {}\n}\n\n/**\n * Builds a CredentialsProvider depending on the type of\n * the credentials passed in.\n */\nexport function makeCredentialsProvider(credentials?: CredentialsSettings) {\n  if (!credentials) {\n    return new EmptyCredentialsProvider();\n  }\n\n  switch (credentials.type) {\n    case 'gapi':\n      return new FirstPartyCredentialsProvider(\n        credentials.client,\n        credentials.sessionIndex || '0'\n      );\n\n    case 'provider':\n      return credentials.client;\n\n    default:\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'makeCredentialsProvider failed due to invalid credential type'\n      );\n  }\n}\n"]}