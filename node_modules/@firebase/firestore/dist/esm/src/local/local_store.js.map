{"version":3,"sources":["../src/local/local_store.ts"],"names":[],"mappings":"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","file":"local_store.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { User } from '../auth/user';\nimport { Query } from '../core/query';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { TargetIdGenerator } from '../core/target_id_generator';\nimport { Timestamp } from '../core/timestamp';\nimport { BatchId, ProtoByteString, TargetId } from '../core/types';\nimport {\n  DocumentKeySet,\n  documentKeySet,\n  DocumentMap,\n  MaybeDocumentMap\n} from '../model/collections';\nimport { MaybeDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { Mutation } from '../model/mutation';\nimport {\n  BATCHID_UNKNOWN,\n  MutationBatch,\n  MutationBatchResult\n} from '../model/mutation_batch';\nimport {\n  RemoteEvent,\n  ResetMapping,\n  TargetChange,\n  UpdateMapping\n} from '../remote/remote_event';\nimport { assert, fail } from '../util/assert';\nimport * as log from '../util/log';\nimport * as objUtils from '../util/obj';\n\nimport { GarbageCollector } from './garbage_collector';\nimport { LocalDocumentsView } from './local_documents_view';\nimport { LocalViewChanges } from './local_view_changes';\nimport { MutationQueue } from './mutation_queue';\nimport { Persistence, PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { QueryCache } from './query_cache';\nimport { QueryData, QueryPurpose } from './query_data';\nimport { ReferenceSet } from './reference_set';\nimport { RemoteDocumentCache } from './remote_document_cache';\nimport { RemoteDocumentChangeBuffer } from './remote_document_change_buffer';\n\nconst LOG_TAG = 'LocalStore';\n\n/** The result of a write to the local store. */\nexport interface LocalWriteResult {\n  batchId: BatchId;\n  changes: MaybeDocumentMap;\n}\n\n/**\n * Local storage in the Firestore client. Coordinates persistence components\n * like the mutation queue and remote document cache to present a\n * latency-compensated view of stored data.\n *\n * The LocalStore is responsible for accepting mutations from the Sync Engine.\n * Writes from the client are put into a queue as provisional Mutations until\n * they are processed by the RemoteStore and confirmed as having been written\n * to the server.\n *\n * The local store provides the local version of documents that have been\n * modified locally. It maintains the constraint:\n *\n *   LocalDocument = RemoteDocument + Active(LocalMutations)\n *\n * (Active mutations are those that are enqueued and have not been previously\n * acknowledged or rejected).\n *\n * The RemoteDocument (\"ground truth\") state is provided via the\n * applyChangeBatch method. It will be some version of a server-provided\n * document OR will be a server-provided document PLUS acknowledged mutations:\n *\n *   RemoteDocument' = RemoteDocument + Acknowledged(LocalMutations)\n *\n * Note that this \"dirty\" version of a RemoteDocument will not be identical to a\n * server base version, since it has LocalMutations added to it pending getting\n * an authoritative copy from the server.\n *\n * Since LocalMutations can be rejected by the server, we have to be able to\n * revert a LocalMutation that has already been applied to the LocalDocument\n * (typically done by replaying all remaining LocalMutations to the\n * RemoteDocument to re-apply).\n *\n * The LocalStore is responsible for the garbage collection of the documents it\n * contains. For now, it every doc referenced by a view, the mutation queue, or\n * the RemoteStore.\n *\n * It also maintains the persistence of mapping queries to resume tokens and\n * target ids. It needs to know this data about queries to properly know what\n * docs it would be allowed to garbage collect.\n *\n * The LocalStore must be able to efficiently execute queries against its local\n * cache of the documents, to provide the initial set of results before any\n * remote changes have been received.\n *\n * Note: In TypeScript, most methods return Promises since the implementation\n * may rely on fetching data from IndexedDB which is async.\n * These Promises will only be rejected on an I/O error or other internal\n * (unexpected) failure (e.g. failed assert) and always represent an\n * unrecoverable error (should be caught / reported by the async_queue).\n */\nexport class LocalStore {\n  /**\n   * The set of all mutations that have been sent but not yet been applied to\n   * the backend.\n   */\n  private mutationQueue: MutationQueue;\n\n  /** The set of all cached remote documents. */\n  private remoteDocuments: RemoteDocumentCache;\n\n  /**\n   * The \"local\" view of all documents (layering mutationQueue on top of\n   * remoteDocumentCache).\n   */\n  private localDocuments: LocalDocumentsView;\n\n  /**\n   * The set of document references maintained by any local views.\n   */\n  private localViewReferences = new ReferenceSet();\n\n  /** Maps a query to the data about that query. */\n  private queryCache: QueryCache;\n\n  /** Maps a targetID to data about its query. */\n  private targetIds = {} as { [targetId: number]: QueryData };\n\n  /** Used to generate targetIDs for queries tracked locally. */\n  private targetIdGenerator = TargetIdGenerator.forLocalStore();\n\n  /**\n   * A heldBatchResult is a mutation batch result (from a write acknowledgement)\n   * that arrived before the watch stream got notified of a snapshot that\n   * includes the write.â€‚So we \"hold\" it until the watch stream catches up. It\n   * ensures that the local write remains visible (latency compensation) and\n   * doesn't temporarily appear reverted because the watch stream is slower than\n   * the write stream and so wasn't reflecting it.\n   *\n   * NOTE: Eventually we want to move this functionality into the remote store.\n   */\n  private heldBatchResults: MutationBatchResult[] = [];\n\n  constructor(\n    /** Manages our in-memory or durable persistence. */\n    private persistence: Persistence,\n    initialUser: User,\n    /**\n     * The garbage collector collects documents that should no longer be\n     * cached (e.g. if they are no longer retained by the above reference sets\n     * and the garbage collector is performing eager collection).\n     */\n    private garbageCollector: GarbageCollector\n  ) {\n    this.mutationQueue = persistence.getMutationQueue(initialUser);\n    this.remoteDocuments = persistence.getRemoteDocumentCache();\n    this.queryCache = persistence.getQueryCache();\n    this.localDocuments = new LocalDocumentsView(\n      this.remoteDocuments,\n      this.mutationQueue\n    );\n    this.garbageCollector.addGarbageSource(this.localViewReferences);\n    this.garbageCollector.addGarbageSource(this.queryCache);\n    this.garbageCollector.addGarbageSource(this.mutationQueue);\n  }\n\n  /** Performs any initial startup actions required by the local store. */\n  start(): Promise<void> {\n    return this.persistence.runTransaction('Start LocalStore', txn => {\n      return this.startMutationQueue(txn).next(() => this.startQueryCache(txn));\n    });\n  }\n\n  /**\n   * Tells the LocalStore that the currently authenticated user has changed.\n   *\n   * In response the local store switches the mutation queue to the new user and\n   * returns any resulting document changes.\n   */\n  handleUserChange(user: User): Promise<MaybeDocumentMap> {\n    return this.persistence.runTransaction('Handle user change', txn => {\n      // Swap out the mutation queue, grabbing the pending mutation batches\n      // before and after.\n      let oldBatches: MutationBatch[];\n      return this.mutationQueue\n        .getAllMutationBatches(txn)\n        .next(promisedOldBatches => {\n          oldBatches = promisedOldBatches;\n\n          this.garbageCollector.removeGarbageSource(this.mutationQueue);\n          this.mutationQueue = this.persistence.getMutationQueue(user);\n          this.garbageCollector.addGarbageSource(this.mutationQueue);\n          return this.startMutationQueue(txn);\n        })\n        .next(() => {\n          // Recreate our LocalDocumentsView using the new\n          // MutationQueue.\n          this.localDocuments = new LocalDocumentsView(\n            this.remoteDocuments,\n            this.mutationQueue\n          );\n          return this.mutationQueue.getAllMutationBatches(txn);\n        })\n        .next(newBatches => {\n          // Union the old/new changed keys.\n          let changedKeys = documentKeySet();\n          for (const batches of [oldBatches, newBatches]) {\n            for (const batch of batches) {\n              for (const mutation of batch.mutations) {\n                changedKeys = changedKeys.add(mutation.key);\n              }\n            }\n          }\n\n          // Return the set of all (potentially) changed documents as the\n          // result of the user change.\n          return this.localDocuments.getDocuments(txn, changedKeys);\n        });\n    });\n  }\n\n  private startQueryCache(\n    txn: PersistenceTransaction\n  ): PersistencePromise<void> {\n    return this.queryCache.start(txn).next(() => {\n      const targetId = this.queryCache.getHighestTargetId();\n      this.targetIdGenerator = TargetIdGenerator.forLocalStore(targetId);\n    });\n  }\n\n  private startMutationQueue(\n    txn: PersistenceTransaction\n  ): PersistencePromise<void> {\n    return this.mutationQueue\n      .start(txn)\n      .next(() => {\n        // If we have any leftover mutation batch results from a prior run,\n        // just drop them.\n        // TODO(http://b/33446471): We probably need to repopulate\n        // heldBatchResults or similar instead, but that is not\n        // straightforward since we're not persisting the write ack versions.\n        this.heldBatchResults = [];\n        return this.mutationQueue.getHighestAcknowledgedBatchId(txn);\n      })\n      .next(highestAck => {\n        // TODO(mikelehen): This is the only usage of\n        // getAllMutationBatchesThroughBatchId(). Consider removing it in\n        // favor of a getAcknowledgedBatches() method.\n        if (highestAck !== BATCHID_UNKNOWN) {\n          return this.mutationQueue.getAllMutationBatchesThroughBatchId(\n            txn,\n            highestAck\n          );\n        } else {\n          return PersistencePromise.resolve([]);\n        }\n      })\n      .next(ackedBatches => {\n        if (ackedBatches.length > 0) {\n          return this.mutationQueue.removeMutationBatches(txn, ackedBatches);\n        } else {\n          return PersistencePromise.resolve();\n        }\n      });\n  }\n\n  /* Accept locally generated Mutations and commit them to storage. */\n  localWrite(mutations: Mutation[]): Promise<LocalWriteResult> {\n    return this.persistence.runTransaction('Locally write mutations', txn => {\n      let batch: MutationBatch;\n      const localWriteTime = Timestamp.now();\n      return this.mutationQueue\n        .addMutationBatch(txn, localWriteTime, mutations)\n        .next(promisedBatch => {\n          batch = promisedBatch;\n          // TODO(koss): This is doing an N^2 update by replaying ALL the\n          // mutations on each document (instead of just the ones added) in\n          // this batch.\n          const keys = batch.keys();\n          return this.localDocuments.getDocuments(txn, keys);\n        })\n        .next((changedDocuments: MaybeDocumentMap) => {\n          return { batchId: batch.batchId, changes: changedDocuments };\n        });\n    });\n  }\n\n  /**\n   * Acknowledge the given batch.\n   *\n   * On the happy path when a batch is acknowledged, the local store will\n   *\n   *  + remove the batch from the mutation queue;\n   *  + apply the changes to the remote document cache;\n   *  + recalculate the latency compensated view implied by those changes (there\n   *    may be mutations in the queue that affect the documents but haven't been\n   *    acknowledged yet); and\n   *  + give the changed documents back the sync engine\n   *\n   * @returns The resulting (modified) documents.\n   */\n  acknowledgeBatch(\n    batchResult: MutationBatchResult\n  ): Promise<MaybeDocumentMap> {\n    return this.persistence.runTransaction('Acknowledge batch', txn => {\n      let affected: DocumentKeySet;\n      return this.mutationQueue\n        .acknowledgeBatch(txn, batchResult.batch, batchResult.streamToken)\n        .next(() => {\n          if (this.shouldHoldBatchResult(batchResult.commitVersion)) {\n            this.heldBatchResults.push(batchResult);\n            affected = documentKeySet();\n            return PersistencePromise.resolve();\n          } else {\n            const documentBuffer = new RemoteDocumentChangeBuffer(\n              this.remoteDocuments\n            );\n            return this.releaseBatchResults(\n              txn,\n              [batchResult],\n              documentBuffer\n            ).next(promisedAffectedKeys => {\n              affected = promisedAffectedKeys;\n              return documentBuffer.apply(txn);\n            });\n          }\n        })\n        .next(() => {\n          return this.mutationQueue.performConsistencyCheck(txn);\n        })\n        .next(() => {\n          return this.localDocuments.getDocuments(txn, affected);\n        });\n    });\n  }\n\n  /**\n   * Remove mutations from the MutationQueue for the specified batch;\n   * LocalDocuments will be recalculated.\n   *\n   * @returns The resulting modified documents.\n   */\n  rejectBatch(batchId: BatchId): Promise<MaybeDocumentMap> {\n    return this.persistence.runTransaction('Reject batch', txn => {\n      let toReject: MutationBatch;\n      let affectedKeys: DocumentKeySet;\n      return this.mutationQueue\n        .lookupMutationBatch(txn, batchId)\n        .next((promisedToReject: MutationBatch | null) => {\n          assert(\n            promisedToReject != null,\n            'Attempt to reject nonexistent batch!'\n          );\n          toReject = promisedToReject!;\n\n          return this.mutationQueue\n            .getHighestAcknowledgedBatchId(txn)\n            .next(lastAcked => {\n              assert(\n                batchId > lastAcked,\n                \"Acknowledged batches can't be rejected.\"\n              );\n              return toReject;\n            });\n        })\n        .next(() => {\n          return this.removeMutationBatch(txn, toReject);\n        })\n        .next(promisedAffectedKeys => {\n          affectedKeys = promisedAffectedKeys;\n          return this.mutationQueue.performConsistencyCheck(txn);\n        })\n        .next(() => {\n          return this.localDocuments.getDocuments(txn, affectedKeys);\n        });\n    });\n  }\n\n  /** Returns the last recorded stream token for the current user. */\n  getLastStreamToken(): Promise<ProtoByteString> {\n    return this.persistence.runTransaction('Get last stream token', txn => {\n      return this.mutationQueue.getLastStreamToken(txn);\n    });\n  }\n\n  /**\n   * Sets the stream token for the current user without acknowledging any\n   * mutation batch. This is usually only useful after a stream handshake or in\n   * response to an error that requires clearing the stream token.\n   */\n  setLastStreamToken(streamToken: ProtoByteString): Promise<void> {\n    return this.persistence.runTransaction('Set last stream token', txn => {\n      return this.mutationQueue.setLastStreamToken(txn, streamToken);\n    });\n  }\n\n  /**\n   * Returns the last consistent snapshot processed (used by the RemoteStore to\n   * determine whether to buffer incoming snapshots from the backend).\n   */\n  getLastRemoteSnapshotVersion(): SnapshotVersion {\n    return this.queryCache.getLastRemoteSnapshotVersion();\n  }\n\n  /**\n   * Update the \"ground-state\" (remote) documents. We assume that the remote\n   * event reflects any write batches that have been acknowledged or rejected\n   * (i.e. we do not re-apply local mutations to updates from this event).\n   *\n   * LocalDocuments are re-calculated if there are remaining mutations in the\n   * queue.\n   */\n  applyRemoteEvent(remoteEvent: RemoteEvent): Promise<MaybeDocumentMap> {\n    const documentBuffer = new RemoteDocumentChangeBuffer(this.remoteDocuments);\n    return this.persistence.runTransaction('Apply remote event', txn => {\n      const promises = [] as Array<PersistencePromise<void>>;\n      objUtils.forEachNumber(\n        remoteEvent.targetChanges,\n        (targetId: TargetId, change: TargetChange) => {\n          // Do not ref/unref unassigned targetIds - it may lead to leaks.\n          let queryData = this.targetIds[targetId];\n          if (!queryData) return;\n\n          const mapping: UpdateMapping | ResetMapping = change.mapping;\n          if (mapping) {\n            // First make sure that all references are deleted\n            if (mapping instanceof ResetMapping) {\n              promises.push(\n                this.queryCache\n                  .removeMatchingKeysForTargetId(txn, targetId)\n                  .next(() => {\n                    return this.queryCache.addMatchingKeys(\n                      txn,\n                      mapping.documents,\n                      targetId\n                    );\n                  })\n              );\n            } else if (mapping instanceof UpdateMapping) {\n              promises.push(\n                this.queryCache\n                  .removeMatchingKeys(txn, mapping.removedDocuments, targetId)\n                  .next(() => {\n                    return this.queryCache.addMatchingKeys(\n                      txn,\n                      mapping.addedDocuments,\n                      targetId\n                    );\n                  })\n              );\n            } else {\n              return fail('Unknown mapping type: ' + JSON.stringify(mapping));\n            }\n          }\n\n          // Update the resume token if the change includes one. Don't clear\n          // any preexisting value.\n          const resumeToken = change.resumeToken;\n          if (resumeToken.length > 0) {\n            queryData = queryData.update({\n              resumeToken,\n              snapshotVersion: change.snapshotVersion\n            });\n            this.targetIds[targetId] = queryData;\n            promises.push(this.queryCache.addQueryData(txn, queryData));\n          }\n        }\n      );\n\n      let changedDocKeys = documentKeySet();\n      remoteEvent.documentUpdates.forEach((key, doc) => {\n        changedDocKeys = changedDocKeys.add(key);\n        promises.push(\n          documentBuffer.getEntry(txn, key).next(existingDoc => {\n            // Make sure we don't apply an old document version to the remote\n            // cache, though we make an exception for SnapshotVersion.MIN which\n            // can happen for manufactured events (e.g. in the case of a limbo\n            // document resolution failing).\n            if (\n              existingDoc == null ||\n              doc.version.equals(SnapshotVersion.MIN) ||\n              doc.version.compareTo(existingDoc.version) >= 0\n            ) {\n              documentBuffer.addEntry(doc);\n            } else {\n              log.debug(\n                LOG_TAG,\n                'Ignoring outdated watch update for ',\n                key,\n                '. Current version:',\n                existingDoc.version,\n                ' Watch version:',\n                doc.version\n              );\n            }\n\n            // The document might be garbage because it was unreferenced by\n            // everything. Make sure to mark it as garbage if it is...\n            this.garbageCollector.addPotentialGarbageKey(key);\n          })\n        );\n      });\n\n      // HACK: The only reason we allow a null snapshot version is so that we\n      // can synthesize remote events when we get permission denied errors while\n      // trying to resolve the state of a locally cached document that is in\n      // limbo.\n      const lastRemoteVersion = this.queryCache.getLastRemoteSnapshotVersion();\n      const remoteVersion = remoteEvent.snapshotVersion;\n      if (!remoteVersion.equals(SnapshotVersion.MIN)) {\n        assert(\n          remoteVersion.compareTo(lastRemoteVersion) >= 0,\n          'Watch stream reverted to previous snapshot?? ' +\n            remoteVersion +\n            ' < ' +\n            lastRemoteVersion\n        );\n        promises.push(\n          this.queryCache.setLastRemoteSnapshotVersion(txn, remoteVersion)\n        );\n      }\n\n      let releasedWriteKeys: DocumentKeySet;\n      return PersistencePromise.waitFor(promises)\n        .next(() => this.releaseHeldBatchResults(txn, documentBuffer))\n        .next(promisedReleasedWriteKeys => {\n          releasedWriteKeys = promisedReleasedWriteKeys;\n          return documentBuffer.apply(txn);\n        })\n        .next(() => {\n          return this.localDocuments.getDocuments(\n            txn,\n            changedDocKeys.unionWith(releasedWriteKeys)\n          );\n        });\n    });\n  }\n\n  /**\n   * Notify local store of the changed views to locally pin documents.\n   */\n  notifyLocalViewChanges(viewChanges: LocalViewChanges[]): Promise<void> {\n    return this.persistence.runTransaction('Notify local view changes', txn => {\n      const promises = [] as Array<PersistencePromise<void>>;\n      for (const view of viewChanges) {\n        promises.push(\n          this.queryCache\n            .getQueryData(txn, view.query)\n            .next((queryData: QueryData | null) => {\n              assert(\n                queryData !== null,\n                'Local view changes contain unallocated query.'\n              );\n              const targetId = queryData!.targetId;\n              this.localViewReferences.addReferences(view.addedKeys, targetId);\n              this.localViewReferences.removeReferences(\n                view.removedKeys,\n                targetId\n              );\n            })\n        );\n      }\n      return PersistencePromise.waitFor(promises);\n    });\n  }\n\n  /**\n   * Gets the mutation batch after the passed in batchId in the mutation queue\n   * or null if empty.\n   * @param afterBatchId If provided, the batch to search after.\n   * @returns The next mutation or null if there wasn't one.\n   */\n  nextMutationBatch(afterBatchId?: BatchId): Promise<MutationBatch | null> {\n    return this.persistence.runTransaction('Get next mutation batch', txn => {\n      if (afterBatchId === undefined) {\n        afterBatchId = BATCHID_UNKNOWN;\n      }\n      return this.mutationQueue.getNextMutationBatchAfterBatchId(\n        txn,\n        afterBatchId\n      );\n    });\n  }\n\n  /**\n   * Read the current value of a Document with a given key or null if not\n   * found - used for testing.\n   */\n  readDocument(key: DocumentKey): Promise<MaybeDocument | null> {\n    return this.persistence.runTransaction('read document', txn => {\n      return this.localDocuments.getDocument(txn, key);\n    });\n  }\n\n  /**\n   * Assigns the given query an internal ID so that its results can be pinned so\n   * they don't get GC'd. A query must be allocated in the local store before\n   * the store can be used to manage its view.\n   */\n  allocateQuery(query: Query): Promise<QueryData> {\n    return this.persistence.runTransaction('Allocate query', txn => {\n      let queryData: QueryData;\n      return this.queryCache\n        .getQueryData(txn, query)\n        .next((cached: QueryData | null) => {\n          if (cached) {\n            // This query has been listened to previously, so reuse the\n            // previous targetID.\n            // TODO(mcg): freshen last accessed date?\n            queryData = cached;\n            return PersistencePromise.resolve();\n          } else {\n            const targetId = this.targetIdGenerator.next();\n            queryData = new QueryData(query, targetId, QueryPurpose.Listen);\n            return this.queryCache.addQueryData(txn, queryData);\n          }\n        })\n        .next(() => {\n          assert(\n            !this.targetIds[queryData.targetId],\n            'Tried to allocate an already allocated query: ' + query\n          );\n          this.targetIds[queryData.targetId] = queryData;\n          return queryData;\n        });\n    });\n  }\n\n  /** Unpin all the documents associated with the given query. */\n  releaseQuery(query: Query): Promise<void> {\n    return this.persistence.runTransaction('Release query', txn => {\n      return this.queryCache\n        .getQueryData(txn, query)\n        .next((queryData: QueryData | null) => {\n          assert(\n            queryData != null,\n            'Tried to release nonexistent query: ' + query\n          );\n          this.localViewReferences.removeReferencesForId(queryData!.targetId);\n          delete this.targetIds[queryData!.targetId];\n          if (this.garbageCollector.isEager) {\n            return this.queryCache.removeQueryData(txn, queryData!);\n          } else {\n            return PersistencePromise.resolve();\n          }\n        })\n        .next(() => {\n          // If this was the last watch target, then we won't get any more\n          // watch snapshots, so we should release any held batch results.\n          if (objUtils.isEmpty(this.targetIds)) {\n            const documentBuffer = new RemoteDocumentChangeBuffer(\n              this.remoteDocuments\n            );\n            return this.releaseHeldBatchResults(txn, documentBuffer).next(\n              () => {\n                documentBuffer.apply(txn);\n              }\n            );\n          } else {\n            return PersistencePromise.resolve();\n          }\n        });\n    });\n  }\n\n  /**\n   * Runs the specified query against all the documents in the local store and\n   * returns the results.\n   */\n  executeQuery(query: Query): Promise<DocumentMap> {\n    return this.persistence.runTransaction('Execute query', txn => {\n      return this.localDocuments.getDocumentsMatchingQuery(txn, query);\n    });\n  }\n\n  /**\n   * Returns the keys of the documents that are associated with the given\n   * target id in the remote table.\n   */\n  remoteDocumentKeys(targetId: TargetId): Promise<DocumentKeySet> {\n    return this.persistence.runTransaction('Remote document keys', txn => {\n      return this.queryCache.getMatchingKeysForTargetId(txn, targetId);\n    });\n  }\n\n  /**\n   * Collect garbage if necessary.\n   * Should be called periodically by Sync Engine to recover resources. The\n   * implementation must guarantee that GC won't happen in other places than\n   * this method call.\n   */\n  collectGarbage(): Promise<void> {\n    // Call collectGarbage regardless of whether isGCEnabled so the referenceSet\n    // doesn't continue to accumulate the garbage keys.\n    return this.persistence.runTransaction('Garbage collection', txn => {\n      return this.garbageCollector.collectGarbage(txn).next(garbage => {\n        const promises = [] as Array<PersistencePromise<void>>;\n        garbage.forEach(key => {\n          promises.push(this.remoteDocuments.removeEntry(txn, key));\n        });\n        return PersistencePromise.waitFor(promises);\n      });\n    });\n  }\n\n  private releaseHeldBatchResults(\n    txn: PersistenceTransaction,\n    documentBuffer: RemoteDocumentChangeBuffer\n  ): PersistencePromise<DocumentKeySet> {\n    const toRelease: MutationBatchResult[] = [];\n    for (const batchResult of this.heldBatchResults) {\n      if (!this.isRemoteUpToVersion(batchResult.commitVersion)) {\n        break;\n      }\n      toRelease.push(batchResult);\n    }\n\n    if (toRelease.length === 0) {\n      return PersistencePromise.resolve(documentKeySet());\n    } else {\n      this.heldBatchResults.splice(0, toRelease.length);\n      return this.releaseBatchResults(txn, toRelease, documentBuffer);\n    }\n  }\n\n  private isRemoteUpToVersion(version: SnapshotVersion): boolean {\n    // If there are no watch targets, then we won't get remote snapshots, and\n    // we are always \"up-to-date.\"\n    const lastRemoteVersion = this.queryCache.getLastRemoteSnapshotVersion();\n    return (\n      version.compareTo(lastRemoteVersion) <= 0 ||\n      objUtils.isEmpty(this.targetIds)\n    );\n  }\n\n  private shouldHoldBatchResult(version: SnapshotVersion): boolean {\n    // Check if watcher isn't up to date or prior results are already held.\n    return (\n      !this.isRemoteUpToVersion(version) || this.heldBatchResults.length > 0\n    );\n  }\n\n  private releaseBatchResults(\n    txn: PersistenceTransaction,\n    batchResults: MutationBatchResult[],\n    documentBuffer: RemoteDocumentChangeBuffer\n  ): PersistencePromise<DocumentKeySet> {\n    let promiseChain = PersistencePromise.resolve();\n    for (const batchResult of batchResults) {\n      promiseChain = promiseChain.next(() =>\n        this.applyWriteToRemoteDocuments(txn, batchResult, documentBuffer)\n      );\n    }\n    return promiseChain.next(() => {\n      return this.removeMutationBatches(\n        txn,\n        batchResults.map(result => result.batch)\n      );\n    });\n  }\n\n  private removeMutationBatch(\n    txn: PersistenceTransaction,\n    batch: MutationBatch\n  ): PersistencePromise<DocumentKeySet> {\n    return this.removeMutationBatches(txn, [batch]);\n  }\n\n  /** Removes all the mutation batches named in the given array. */\n  private removeMutationBatches(\n    txn: PersistenceTransaction,\n    batches: MutationBatch[]\n  ): PersistencePromise<DocumentKeySet> {\n    let affectedDocs = documentKeySet();\n    for (const batch of batches) {\n      for (const mutation of batch.mutations) {\n        const key = mutation.key;\n        affectedDocs = affectedDocs.add(key);\n      }\n    }\n\n    return this.mutationQueue\n      .removeMutationBatches(txn, batches)\n      .next(() => affectedDocs);\n  }\n\n  private applyWriteToRemoteDocuments(\n    txn: PersistenceTransaction,\n    batchResult: MutationBatchResult,\n    documentBuffer: RemoteDocumentChangeBuffer\n  ): PersistencePromise<void> {\n    const batch = batchResult.batch;\n    const docKeys = batch.keys();\n    let promiseChain = PersistencePromise.resolve();\n    docKeys.forEach(docKey => {\n      promiseChain = promiseChain\n        .next(() => {\n          return documentBuffer.getEntry(txn, docKey);\n        })\n        .next((remoteDoc: MaybeDocument | null) => {\n          let doc = remoteDoc;\n          const ackVersion = batchResult.docVersions.get(docKey);\n          assert(\n            ackVersion !== null,\n            'ackVersions should contain every doc in the write.'\n          );\n          if (!doc || doc.version.compareTo(ackVersion!) < 0) {\n            doc = batch.applyToRemoteDocument(docKey, doc, batchResult);\n            if (!doc) {\n              assert(\n                !remoteDoc,\n                'Mutation batch ' +\n                  batch +\n                  ' applied to document ' +\n                  remoteDoc +\n                  ' resulted in null'\n              );\n            } else {\n              documentBuffer.addEntry(doc);\n            }\n          }\n        });\n    });\n    return promiseChain;\n  }\n}\n"]}