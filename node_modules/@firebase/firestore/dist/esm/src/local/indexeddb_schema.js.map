{"version":3,"sources":["../src/local/indexeddb_schema.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;GAcG;AAMH,OAAO,EAAE,MAAM,EAAE,MAAM,gBAAgB,CAAC;AAExC,OAAO,EAAE,MAAM,EAAuB,MAAM,yBAAyB,CAAC;AAEtE,MAAM,CAAC,IAAM,cAAc,GAAG,CAAC,CAAC;AAEhC,gFAAgF;AAChF,MAAM,4BAA4B,EAAe,EAAE,UAAkB;IACnE,MAAM,CAAC,UAAU,KAAK,CAAC,EAAE,kCAAkC,GAAG,UAAU,CAAC,CAAC;IAE1E,EAAE,CAAC,iBAAiB,CAAC,eAAe,CAAC,KAAK,EAAE;QAC1C,OAAO,EAAE,eAAe,CAAC,OAAO;KACjC,CAAC,CAAC;IAEH,sEAAsE;IACtE,8DAA8D;IAC9D,EAAE,CAAC,iBAAiB;IAClB,kCAAkC;IAClC,eAAe,CAAC,KAAK,EACrB,EAAE,OAAO,EAAE,eAAe,CAAC,OAAc,EAAE,CAC5C,CAAC;IAEF,IAAM,oBAAoB,GAAG,EAAE,CAAC,iBAAiB;IAC/C,kCAAkC;IAClC,gBAAgB,CAAC,KAAK,EACtB,EAAE,OAAO,EAAE,gBAAgB,CAAC,OAAc,EAAE,CAC7C,CAAC;IACF,oBAAoB,CAAC,WAAW,CAC9B,gBAAgB,CAAC,oBAAoB,EACrC,gBAAgB,CAAC,sBAAsB,EACvC,EAAE,MAAM,EAAE,IAAI,EAAE,CACjB,CAAC;IAEF,IAAM,WAAW,GAAG,EAAE,CAAC,iBAAiB,CAAC,QAAQ,CAAC,KAAK,EAAE;QACvD,OAAO,EAAE,QAAQ,CAAC,OAAO;KAC1B,CAAC,CAAC;IACH,gEAAgE;IAChE,WAAW,CAAC,WAAW,CACrB,QAAQ,CAAC,qBAAqB,EAC9B,QAAQ,CAAC,mBAAmB,EAC5B,EAAE,MAAM,EAAE,IAAI,EAAE,CACjB,CAAC;IAEF,2EAA2E;IAC3E,WAAW;IACX,EAAE,CAAC,iBAAiB,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;IAC/C,EAAE,CAAC,iBAAiB,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;IAC7C,EAAE,CAAC,iBAAiB,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;IACpC,EAAE,CAAC,iBAAiB,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;AAC7C,CAAC;AAED;;GAEG;AACH;IACE,qBAAmB,OAAe,EAAS,KAAa;QAArC,YAAO,GAAP,OAAO,CAAQ;QAAS,UAAK,GAAL,KAAK,CAAQ;IAAG,CAAC;IAC9D,kBAAC;AAAD,CAFA,AAEC,IAAA;;AAKD;;;;;;;GAOG;AACH;IAIE,iBAAmB,OAAe,EAAS,gBAAwB;QAAhD,YAAO,GAAP,OAAO,CAAQ;QAAS,qBAAgB,GAAhB,gBAAgB,CAAQ;IAAG,CAAC;IAHvE,0CAA0C;IACnC,aAAK,GAAG,OAAO,CAAC;IAGzB,cAAC;CALD,AAKC,IAAA;SALY,OAAO;AAUpB;;;;;GAKG;AACH;IAOE;QACE;;WAEG;QACI,MAAc;QACrB;;;;;WAKG;QACI,uBAA+B;QACtC;;;;;;;;WAQG;QACI,eAAuB;QAjBvB,WAAM,GAAN,MAAM,CAAQ;QAOd,4BAAuB,GAAvB,uBAAuB,CAAQ;QAU/B,oBAAe,GAAf,eAAe,CAAQ;IAC7B,CAAC;IA5BJ,2CAA2C;IACpC,qBAAK,GAAG,gBAAgB,CAAC;IAEhC,+DAA+D;IACxD,uBAAO,GAAG,QAAQ,CAAC;IAyB5B,sBAAC;CA9BD,AA8BC,IAAA;SA9BY,eAAe;AAmC5B;;;;;;GAMG;AACH;IAOE;QACE;;WAEG;QACI,MAAc;QACrB;;;WAGG;QACI,OAAgB;QACvB;;;WAGG;QACI,gBAAwB;QAC/B;;;;WAIG;QACI,SAAsB;QAhBtB,WAAM,GAAN,MAAM,CAAQ;QAKd,YAAO,GAAP,OAAO,CAAS;QAKhB,qBAAgB,GAAhB,gBAAgB,CAAQ;QAMxB,cAAS,GAAT,SAAS,CAAa;IAC5B,CAAC;IA3BJ,2CAA2C;IACpC,qBAAK,GAAG,WAAW,CAAC;IAE3B,0EAA0E;IACnE,uBAAO,GAAG,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;IAwBzC,sBAAC;CA7BD,AA6BC,IAAA;SA7BY,eAAe;AAsC5B;;;;;;GAMG;AACH;IA0CE;IAAuB,CAAC;IAvCxB;;;OAGG;IACI,gCAAa,GAApB,UAAqB,MAAc;QACjC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC;IAClB,CAAC;IAED;;;OAGG;IACI,gCAAa,GAApB,UACE,MAAc,EACd,IAAkB;QAElB,MAAM,CAAC,CAAC,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;IAChC,CAAC;IAED;;;OAGG;IACI,sBAAG,GAAV,UACE,MAAc,EACd,IAAkB,EAClB,OAAgB;QAEhB,MAAM,CAAC,CAAC,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,EAAE,OAAO,CAAC,CAAC;IACzC,CAAC;IA/BM,wBAAK,GAAG,mBAAmB,CAAC;IAiCnC;;;;;OAKG;IACI,8BAAW,GAAG,IAAI,kBAAkB,EAAE,CAAC;IAGhD,yBAAC;CA3CD,AA2CC,IAAA;SA3CY,kBAAkB;AAmD/B;;;GAGG;AACH;IACE,sBAAmB,IAAc,EAAS,QAAqB;QAA5C,SAAI,GAAJ,IAAI,CAAU;QAAS,aAAQ,GAAR,QAAQ,CAAa;IAAG,CAAC;IACrE,mBAAC;AAAD,CAFA,AAEC,IAAA;;AAED;;;;;;;GAOG;AACH;IAGE;QACE;;;WAGG;QACI,UAA+B;QACtC;;;WAGG;QACI,QAA6B;QAL7B,eAAU,GAAV,UAAU,CAAqB;QAK/B,aAAQ,GAAR,QAAQ,CAAqB;IACnC,CAAC;IAbG,sBAAK,GAAG,iBAAiB,CAAC;IAcnC,uBAAC;CAfD,AAeC,IAAA;SAfY,gBAAgB;AA6B7B;;;;;;;;GAQG;AACH;IAgBE;QACE;;;;;;;WAOG;QACI,QAAkB;QACzB;;WAEG;QACI,WAAmB;QAC1B;;;;WAIG;QACI,QAAqB;QAC5B;;;;;;;;;;;;;;;;WAgBG;QACI,WAAmB;QAC1B;;;;;;;;;;;;;WAaG;QACI,wBAAgC;QACvC;;;;;;WAMG;QACI,KAAc;QAnDd,aAAQ,GAAR,QAAQ,CAAU;QAIlB,gBAAW,GAAX,WAAW,CAAQ;QAMnB,aAAQ,GAAR,QAAQ,CAAa;QAkBrB,gBAAW,GAAX,WAAW,CAAQ;QAenB,6BAAwB,GAAxB,wBAAwB,CAAQ;QAQhC,UAAK,GAAL,KAAK,CAAS;IACpB,CAAC;IA5EG,cAAK,GAAG,SAAS,CAAC;IAEzB,iEAAiE;IAC1D,gBAAO,GAAG,UAAU,CAAC;IAE5B,0CAA0C;IACnC,8BAAqB,GAAG,mBAAmB,CAAC;IAEnD;;;;OAIG;IACI,4BAAmB,GAAG,CAAC,aAAa,EAAE,UAAU,CAAC,CAAC;IAgE3D,eAAC;CA9ED,AA8EC,IAAA;SA9EY,QAAQ;AAsFrB;;;;GAIG;AACH;IAaE;QACE;;WAEG;QACI,QAAkB;QACzB;;WAEG;QACI,IAAyB;QAJzB,aAAQ,GAAR,QAAQ,CAAU;QAIlB,SAAI,GAAJ,IAAI,CAAqB;IAC/B,CAAC;IArBJ,2CAA2C;IACpC,sBAAK,GAAG,iBAAiB,CAAC;IAEjC,yEAAyE;IAClE,wBAAO,GAAG,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC;IAEtC,4CAA4C;IACrC,qCAAoB,GAAG,sBAAsB,CAAC;IAErD,qEAAqE;IAC9D,uCAAsB,GAAG,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;IAYvD,uBAAC;CAvBD,AAuBC,IAAA;SAvBY,gBAAgB;AA8B7B;;;;;GAKG;AACH;IAQE;QACE;;;;WAIG;QACI,eAAyB;QAChC;;;;WAIG;QACI,2BAAmC;QAC1C;;;;;;;WAOG;QACI,yBAAsC;QAftC,oBAAe,GAAf,eAAe,CAAU;QAMzB,gCAA2B,GAA3B,2BAA2B,CAAQ;QASnC,8BAAyB,GAAzB,yBAAyB,CAAa;IAC5C,CAAC;IA7BJ;;;OAGG;IACI,kBAAG,GAAG,iBAAiB,CAAC;IACxB,oBAAK,GAAG,cAAc,CAAC;IAyBhC,qBAAC;CA/BD,AA+BC,IAAA;SA/BY,cAAc;AAiC3B;;;GAGG;AACH,MAAM,CAAC,IAAM,UAAU,GAAG;IACxB,eAAe,CAAC,KAAK;IACrB,eAAe,CAAC,KAAK;IACrB,kBAAkB,CAAC,KAAK;IACxB,gBAAgB,CAAC,KAAK;IACtB,QAAQ,CAAC,KAAK;IACd,OAAO,CAAC,KAAK;IACb,cAAc,CAAC,KAAK;IACpB,gBAAgB,CAAC,KAAK;CACvB,CAAC","file":"indexeddb_schema.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '../protos/firestore_proto_api';\nimport { BatchId } from '../core/types';\nimport { TargetId } from '../core/types';\nimport { ResourcePath } from '../model/path';\nimport { assert } from '../util/assert';\n\nimport { encode, EncodedResourcePath } from './encoded_resource_path';\n\nexport const SCHEMA_VERSION = 1;\n\n/** Performs database creation and (in the future) upgrades between versions. */\nexport function createOrUpgradeDb(db: IDBDatabase, oldVersion: number): void {\n  assert(oldVersion === 0, 'Unexpected upgrade from version ' + oldVersion);\n\n  db.createObjectStore(DbMutationQueue.store, {\n    keyPath: DbMutationQueue.keyPath\n  });\n\n  // TODO(mikelehen): Get rid of \"as any\" if/when TypeScript fixes their\n  // types. https://github.com/Microsoft/TypeScript/issues/14322\n  db.createObjectStore(\n    // tslint:disable-next-line:no-any\n    DbMutationBatch.store,\n    { keyPath: DbMutationBatch.keyPath as any }\n  );\n\n  const targetDocumentsStore = db.createObjectStore(\n    // tslint:disable-next-line:no-any\n    DbTargetDocument.store,\n    { keyPath: DbTargetDocument.keyPath as any }\n  );\n  targetDocumentsStore.createIndex(\n    DbTargetDocument.documentTargetsIndex,\n    DbTargetDocument.documentTargetsKeyPath,\n    { unique: true }\n  );\n\n  const targetStore = db.createObjectStore(DbTarget.store, {\n    keyPath: DbTarget.keyPath\n  });\n  // NOTE: This is unique only because the TargetId is the suffix.\n  targetStore.createIndex(\n    DbTarget.queryTargetsIndexName,\n    DbTarget.queryTargetsKeyPath,\n    { unique: true }\n  );\n\n  // NOTE: keys for these stores are specified explicitly rather than using a\n  // keyPath.\n  db.createObjectStore(DbDocumentMutation.store);\n  db.createObjectStore(DbRemoteDocument.store);\n  db.createObjectStore(DbOwner.store);\n  db.createObjectStore(DbTargetGlobal.store);\n}\n\n/**\n * Wrapper class to store timestamps (seconds and nanos) in IndexedDb objects.\n */\nexport class DbTimestamp {\n  constructor(public seconds: number, public nanos: number) {}\n}\n\n// The key for the singleton object in the 'owner' store is 'owner'.\nexport type DbOwnerKey = 'owner';\n\n/**\n * A singleton object to be stored in the 'owner' store in IndexedDb.\n *\n * A given database can be owned by a single tab at a given time. That tab\n * must validate that it is still the owner before every write operation and\n * should regularly write an updated timestamp to prevent other tabs from\n * \"stealing\" ownership of the db.\n */\nexport class DbOwner {\n  /** Name of the IndexedDb object store. */\n  static store = 'owner';\n\n  constructor(public ownerId: string, public leaseTimestampMs: number) {}\n}\n\n/** Object keys in the 'mutationQueues' store are userId strings. */\nexport type DbMutationQueueKey = string;\n\n/**\n * An object to be stored in the 'mutationQueues' store in IndexedDb.\n *\n * Each user gets a single queue of MutationBatches to apply to the server.\n * DbMutationQueue tracks the metadata about the queue.\n */\nexport class DbMutationQueue {\n  /** Name of the IndexedDb object store.  */\n  static store = 'mutationQueues';\n\n  /** Keys are automatically assigned via the userId property. */\n  static keyPath = 'userId';\n\n  constructor(\n    /**\n     * The normalized user ID to which this queue belongs.\n     */\n    public userId: string,\n    /**\n     * An identifier for the highest numbered batch that has been acknowledged\n     * by the server. All MutationBatches in this queue with batchIds less\n     * than or equal to this value are considered to have been acknowledged by\n     * the server.\n     */\n    public lastAcknowledgedBatchId: number,\n    /**\n     * A stream token that was previously sent by the server.\n     *\n     * See StreamingWriteRequest in datastore.proto for more details about\n     * usage.\n     *\n     * After sending this token, earlier tokens may not be used anymore so\n     * only a single stream token is retained.\n     */\n    public lastStreamToken: string\n  ) {}\n}\n\n/** keys in the 'mutations' object store are [userId, batchId] pairs. */\nexport type DbMutationBatchKey = [string, BatchId];\n\n/**\n * An object to be stored in the 'mutations' store in IndexedDb.\n *\n * Represents a batch of user-level mutations intended to be sent to the server\n * in a single write. Each user-level batch gets a separate DbMutationBatch\n * with a new batchId.\n */\nexport class DbMutationBatch {\n  /** Name of the IndexedDb object store.  */\n  static store = 'mutations';\n\n  /** Keys are automatically assigned via the userId, batchId properties. */\n  static keyPath = ['userId', 'batchId'];\n\n  constructor(\n    /**\n     * The normalized user ID to which this batch belongs.\n     */\n    public userId: string,\n    /**\n     * An identifier for this batch, allocated by the mutation queue in a\n     * monotonically increasing manner.\n     */\n    public batchId: BatchId,\n    /**\n     * The local write time of the batch, stored as milliseconds since the\n     * epoch.\n     */\n    public localWriteTimeMs: number,\n    /**\n     * A list of mutations to apply. All mutations will be applied atomically.\n     *\n     * Mutations are serialized via JsonProtoSerializer.toMutation().\n     */\n    public mutations: api.Write[]\n  ) {}\n}\n\n/**\n * The key for a db document mutation, which is made up of a userID, path, and\n * batchId. Note that the path must be serialized into a form that indexedDB can\n * sort.\n */\nexport type DbDocumentMutationKey = [string, EncodedResourcePath, BatchId];\n\n/**\n * An object to be stored in the 'documentMutations' store in IndexedDb.\n *\n * A manually maintained index of all the mutation batches that affect a given\n * document key. The rows in this table are references based on the contents of\n * DbMutationBatch.mutations.\n */\nexport class DbDocumentMutation {\n  static store = 'documentMutations';\n\n  /**\n   * Creates a [userId] key for use in the DbDocumentMutations index to iterate\n   * over all of a user's document mutations.\n   */\n  static prefixForUser(userId: string): [string] {\n    return [userId];\n  }\n\n  /**\n   * Creates a [userId, encodedPath] key for use in the DbDocumentMutations\n   * index to iterate over all at document mutations for a given path or lower.\n   */\n  static prefixForPath(\n    userId: string,\n    path: ResourcePath\n  ): [string, EncodedResourcePath] {\n    return [userId, encode(path)];\n  }\n\n  /**\n   * Creates a full index key of [userId, encodedPath, batchId] for inserting\n   * and deleting into the DbDocumentMutations index.\n   */\n  static key(\n    userId: string,\n    path: ResourcePath,\n    batchId: BatchId\n  ): DbDocumentMutationKey {\n    return [userId, encode(path), batchId];\n  }\n\n  /**\n   * Because we store all the useful information for this store in the key,\n   * there is no useful information to store as the value. The raw (unencoded)\n   * path cannot be stored because IndexedDb doesn't store prototype\n   * information.\n   */\n  static PLACEHOLDER = new DbDocumentMutation();\n\n  private constructor() {}\n}\n\n/**\n * A key in the 'remoteDocuments' object store is a string array containing the\n * segments that make up the path.\n */\nexport type DbRemoteDocumentKey = string[];\n\n/**\n * Represents the known absence of a document at a particular version.\n * Stored in IndexedDb as part of a DbRemoteDocument object.\n */\nexport class DbNoDocument {\n  constructor(public path: string[], public readTime: DbTimestamp) {}\n}\n\n/**\n * An object to be stored in the 'remoteDocuments' store in IndexedDb. It\n * represents either a cached document (if it exists) or a cached \"no-document\"\n * (if it is known to not exist).\n *\n * Note: This is the persisted equivalent of a MaybeDocument and could perhaps\n * be made more general if necessary.\n */\nexport class DbRemoteDocument {\n  static store = 'remoteDocuments';\n\n  constructor(\n    /**\n     * Set to an instance of a DbNoDocument if it is known that no document\n     * exists.\n     */\n    public noDocument: DbNoDocument | null,\n    /**\n     * Set to an instance of a Document if there's a cached version of the\n     * document.\n     */\n    public document: api.Document | null\n  ) {}\n}\n\n/**\n * A key in the 'targets' object store is a targetId of the query.\n */\nexport type DbTargetKey = TargetId;\n\n/**\n * The persisted type for a query nested with in the 'targets' store in\n * IndexedDb. We use the proto definitions for these two kinds of queries in\n * order to avoid writing extra serialization logic.\n */\nexport type DbQuery = api.QueryTarget | api.DocumentsTarget;\n\n/**\n * An object to be stored in the 'targets' store in IndexedDb.\n *\n * This is based on and should be kept in sync with the proto used in the iOS\n * client.\n *\n * Each query the client listens to against the server is tracked on disk so\n * that the query can be efficiently resumed on restart.\n */\nexport class DbTarget {\n  static store = 'targets';\n\n  /** Keys are automatically assigned via the targetId property. */\n  static keyPath = 'targetId';\n\n  /** The name of the queryTargets index. */\n  static queryTargetsIndexName = 'queryTargetsIndex';\n\n  /**\n   * The index of all canonicalIds to the targets that they match. This is not\n   * a unique mapping because canonicalId does not promise a unique name for all\n   * possible queries, so we append the targetId to make the mapping unique.\n   */\n  static queryTargetsKeyPath = ['canonicalId', 'targetId'];\n\n  constructor(\n    /**\n     * An auto-generated sequential numeric identifier for the query.\n     *\n     * Queries are stored using their canonicalId as the key, but these\n     * canonicalIds can be quite long so we additionally assign a unique\n     * queryId which can be used by referenced data structures (e.g.\n     * indexes) to minimize the on-disk cost.\n     */\n    public targetId: TargetId,\n    /**\n     * The canonical string representing this query. This is not unique.\n     */\n    public canonicalId: string,\n    /**\n     * The last readTime received from the Watch Service for this query.\n     *\n     * This is the same value as TargetChange.read_time in the protos.\n     */\n    public readTime: DbTimestamp,\n    /**\n     * An opaque, server-assigned token that allows watching a query to be\n     * resumed after disconnecting without retransmitting all the data\n     * that matches the query. The resume token essentially identifies a\n     * point in time from which the server should resume sending results.\n     *\n     * This is related to the snapshotVersion in that the resumeToken\n     * effectively also encodes that value, but the resumeToken is opaque\n     * and sometimes encodes additional information.\n     *\n     * A consequence of this is that the resumeToken should be used when\n     * asking the server to reason about where this client is in the watch\n     * stream, but the client should use the snapshotVersion for its own\n     * purposes.\n     *\n     * This is the same value as TargetChange.resume_token in the protos.\n     */\n    public resumeToken: string,\n    /**\n     * A sequence number representing the last time this query was\n     * listened to, used for garbage collection purposes.\n     *\n     * Conventionally this would be a timestamp value, but device-local\n     * clocks are unreliable and they must be able to create new listens\n     * even while disconnected. Instead this should be a monotonically\n     * increasing number that's incremented on each listen call.\n     *\n     * This is different from the queryId since the queryId is an\n     * immutable identifier assigned to the Query on first use while\n     * lastListenSequenceNumber is updated every time the query is\n     * listened to.\n     */\n    public lastListenSequenceNumber: number,\n    /**\n     * The query for this target.\n     *\n     * Because canonical ids are not unique we must store the actual query. We\n     * use the proto to have an object we can persist without having to\n     * duplicate translation logic to and from a `Query` object.\n     */\n    public query: DbQuery\n  ) {}\n}\n\n/**\n * The key for a DbTargetDocument, containing a targetId and an encoded resource\n * path.\n */\nexport type DbTargetDocumentKey = [TargetId, EncodedResourcePath];\n\n/**\n * An object representing an association between a target and a document.\n * Stored in the targetDocument object store to store the documents tracked by a\n * particular target.\n */\nexport class DbTargetDocument {\n  /** Name of the IndexedDb object store.  */\n  static store = 'targetDocuments';\n\n  /** Keys are automatically assigned via the targetId, path properties. */\n  static keyPath = ['targetId', 'path'];\n\n  /** The index name for the reverse index. */\n  static documentTargetsIndex = 'documentTargetsIndex';\n\n  /** We also need to create the reverse index for these properties. */\n  static documentTargetsKeyPath = ['path', 'targetId'];\n\n  constructor(\n    /**\n     * The targetId identifying a target.\n     */\n    public targetId: TargetId,\n    /**\n     * The path to the document, as encoded in the key.\n     */\n    public path: EncodedResourcePath\n  ) {}\n}\n\n/**\n * The type to represent the single allowed key for the DbTargetGlobal store.\n */\nexport type DbTargetGlobalKey = typeof DbTargetGlobal.key;\n\n/**\n * A record of global state tracked across all Targets, tracked separately\n * to avoid the need for extra indexes.\n *\n * This should be kept in-sync with the proto used in the iOS client.\n */\nexport class DbTargetGlobal {\n  /**\n   * The key string used for the single object that exists in the\n   * DbTargetGlobal store.\n   */\n  static key = 'targetGlobalKey';\n  static store = 'targetGlobal';\n\n  constructor(\n    /**\n     * The highest numbered target id across all targets.\n     *\n     * See DbTarget.targetId.\n     */\n    public highestTargetId: TargetId,\n    /**\n     * The highest numbered lastListenSequenceNumber across all targets.\n     *\n     * See DbTarget.lastListenSequenceNumber.\n     */\n    public highestListenSequenceNumber: number,\n    /**\n     * A global snapshot version representing the last consistent snapshot we\n     * received from the backend. This is monotonically increasing and any\n     * snapshots received from the backend prior to this version (e.g. for\n     * targets resumed with a resumeToken) should be suppressed (buffered)\n     * until the backend has caught up to this snapshot version again. This\n     * prevents our cache from ever going backwards in time.\n     */\n    public lastRemoteSnapshotVersion: DbTimestamp\n  ) {}\n}\n\n/**\n * The list of all IndexedDB stored used by the SDK. This is used when creating\n * transactions so that access across all stores is done atomically.\n */\nexport const ALL_STORES = [\n  DbMutationQueue.store,\n  DbMutationBatch.store,\n  DbDocumentMutation.store,\n  DbRemoteDocument.store,\n  DbTarget.store,\n  DbOwner.store,\n  DbTargetGlobal.store,\n  DbTargetDocument.store\n];\n"]}