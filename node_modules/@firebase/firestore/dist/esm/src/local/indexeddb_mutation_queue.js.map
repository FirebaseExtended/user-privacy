{"version":3,"sources":["../src/local/indexeddb_mutation_queue.ts"],"names":[],"mappings":"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","file":"indexeddb_mutation_queue.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { User } from '../auth/user';\nimport { Query } from '../core/query';\nimport { Timestamp } from '../core/timestamp';\nimport { BatchId, ProtoByteString } from '../core/types';\nimport { DocumentKey } from '../model/document_key';\nimport { Mutation } from '../model/mutation';\nimport { BATCHID_UNKNOWN, MutationBatch } from '../model/mutation_batch';\nimport { ResourcePath } from '../model/path';\nimport { assert, fail } from '../util/assert';\nimport { immediatePredecessor, primitiveComparator } from '../util/misc';\nimport { SortedSet } from '../util/sorted_set';\n\nimport * as EncodedResourcePath from './encoded_resource_path';\nimport { GarbageCollector } from './garbage_collector';\nimport {\n  DbDocumentMutation,\n  DbDocumentMutationKey,\n  DbMutationBatch,\n  DbMutationBatchKey,\n  DbMutationQueue,\n  DbMutationQueueKey\n} from './indexeddb_schema';\nimport { LocalSerializer } from './local_serializer';\nimport { MutationQueue } from './mutation_queue';\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { SimpleDbStore, SimpleDbTransaction } from './simple_db';\n\n/** A mutation queue for a specific user, backed by IndexedDB. */\nexport class IndexedDbMutationQueue implements MutationQueue {\n  /**\n   * Next value to use when assigning sequential IDs to each mutation batch.\n   *\n   * NOTE: There can only be one IndexedDbMutationQueue for a given db at a\n   * time, hence it is safe to track nextBatchID as an instance-level property.\n   * Should we ever relax this constraint we'll need to revisit this.\n   */\n  private nextBatchId: BatchId;\n\n  /**\n   * A write-through cache copy of the metadata describing the current queue.\n   */\n  private metadata: DbMutationQueue;\n\n  private garbageCollector: GarbageCollector | null = null;\n\n  constructor(\n    /**\n     * The normalized userId (e.g. null UID => \"\" userId) used to store /\n     * retrieve mutations.\n     */\n    private userId: string,\n    private serializer: LocalSerializer\n  ) {}\n\n  /**\n   * Creates a new mutation queue for the given user.\n   * @param user The user for which to create a mutation queue.\n   * @param serializer The serializer to use when persisting to IndexedDb.\n   */\n  static forUser(user: User, serializer: LocalSerializer) {\n    // TODO(mcg): Figure out what constraints there are on userIDs\n    // In particular, are there any reserved characters? are empty ids allowed?\n    // For the moment store these together in the same mutations table assuming\n    // that empty userIDs aren't allowed.\n    assert(user.uid !== '', 'UserID must not be an empty string.');\n    const userId = user.isUnauthenticated() ? '' : user.uid!;\n    return new IndexedDbMutationQueue(userId, serializer);\n  }\n\n  start(transaction: PersistenceTransaction): PersistencePromise<void> {\n    return IndexedDbMutationQueue.loadNextBatchIdFromDb(transaction)\n      .next(nextBatchId => {\n        this.nextBatchId = nextBatchId;\n        return mutationQueuesStore(transaction).get(this.userId);\n      })\n      .next((metadata: DbMutationQueue | null) => {\n        if (!metadata) {\n          metadata = new DbMutationQueue(\n            this.userId,\n            BATCHID_UNKNOWN,\n            /*lastStreamToken=*/ ''\n          );\n        }\n        this.metadata = metadata;\n\n        // On restart, nextBatchId may end up lower than\n        // lastAcknowledgedBatchId since it's computed from the queue\n        // contents, and there may be no mutations in the queue. In this\n        // case, we need to reset lastAcknowledgedBatchId (which is safe\n        // since the queue must be empty).\n        if (this.metadata.lastAcknowledgedBatchId >= this.nextBatchId) {\n          return this.checkEmpty(transaction).next(empty => {\n            assert(\n              empty,\n              'Reset nextBatchID is only possible when the queue is empty'\n            );\n\n            this.metadata.lastAcknowledgedBatchId = BATCHID_UNKNOWN;\n            return mutationQueuesStore(transaction).put(this.metadata);\n          });\n        } else {\n          return PersistencePromise.resolve();\n        }\n      });\n  }\n\n  /**\n   * Returns one larger than the largest batch ID that has been stored. If there\n   * are no mutations returns 0. Note that batch IDs are global.\n   */\n  static loadNextBatchIdFromDb(\n    txn: PersistenceTransaction\n  ): PersistencePromise<BatchId> {\n    let maxBatchId = BATCHID_UNKNOWN;\n    return mutationsStore(txn)\n      .iterate({ reverse: true }, (key, batch, control) => {\n        const [userId, batchId] = key;\n        if (batchId > maxBatchId) {\n          maxBatchId = batch.batchId;\n        }\n\n        if (userId === '') {\n          // We can't compute a predecessor for the empty string, since it\n          // is lexographically first. That also means that no other\n          // userIds can come before this one, so we can just exit early.\n          control.done();\n        } else {\n          const nextUser = immediatePredecessor(userId);\n          control.skip([nextUser]);\n        }\n      })\n      .next(() => maxBatchId + 1);\n  }\n\n  checkEmpty(transaction: PersistenceTransaction): PersistencePromise<boolean> {\n    let empty = true;\n    const range = IDBKeyRange.bound(\n      this.keyForBatchId(Number.NEGATIVE_INFINITY),\n      this.keyForBatchId(Number.POSITIVE_INFINITY)\n    );\n    return mutationsStore(transaction)\n      .iterate({ range }, (key, value, control) => {\n        empty = false;\n        control.done();\n      })\n      .next(() => empty);\n  }\n\n  getNextBatchId(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<BatchId> {\n    return PersistencePromise.resolve(this.nextBatchId);\n  }\n\n  getHighestAcknowledgedBatchId(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<BatchId> {\n    return PersistencePromise.resolve(this.metadata.lastAcknowledgedBatchId);\n  }\n\n  acknowledgeBatch(\n    transaction: PersistenceTransaction,\n    batch: MutationBatch,\n    streamToken: ProtoByteString\n  ): PersistencePromise<void> {\n    const batchId = batch.batchId;\n    assert(\n      batchId > this.metadata.lastAcknowledgedBatchId,\n      'Mutation batchIDs must be acknowledged in order'\n    );\n\n    this.metadata.lastAcknowledgedBatchId = batchId;\n    this.metadata.lastStreamToken = validateStreamToken(streamToken);\n\n    return mutationQueuesStore(transaction).put(this.metadata);\n  }\n\n  getLastStreamToken(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<ProtoByteString> {\n    return PersistencePromise.resolve(this.metadata.lastStreamToken);\n  }\n\n  setLastStreamToken(\n    transaction: PersistenceTransaction,\n    streamToken: ProtoByteString\n  ): PersistencePromise<void> {\n    this.metadata.lastStreamToken = validateStreamToken(streamToken);\n    return mutationQueuesStore(transaction).put(this.metadata);\n  }\n\n  addMutationBatch(\n    transaction: PersistenceTransaction,\n    localWriteTime: Timestamp,\n    mutations: Mutation[]\n  ): PersistencePromise<MutationBatch> {\n    const batchId = this.nextBatchId;\n    this.nextBatchId++;\n    const batch = new MutationBatch(batchId, localWriteTime, mutations);\n\n    const dbBatch = this.serializer.toDbMutationBatch(this.userId, batch);\n\n    return mutationsStore(transaction)\n      .put(dbBatch)\n      .next(() => {\n        const promises: Array<PersistencePromise<void>> = [];\n        for (const mutation of mutations) {\n          const encodedPath = EncodedResourcePath.encode(mutation.key.path);\n          const indexKey = DbDocumentMutation.key(\n            this.userId,\n            mutation.key.path,\n            batchId\n          );\n          documentMutationsStore(transaction).put(\n            indexKey,\n            DbDocumentMutation.PLACEHOLDER\n          );\n        }\n        return PersistencePromise.waitFor(promises);\n      })\n      .next(() => {\n        return batch;\n      });\n  }\n\n  lookupMutationBatch(\n    transaction: PersistenceTransaction,\n    batchId: BatchId\n  ): PersistencePromise<MutationBatch | null> {\n    return mutationsStore(transaction)\n      .get(this.keyForBatchId(batchId))\n      .next(\n        dbBatch =>\n          dbBatch ? this.serializer.fromDbMutationBatch(dbBatch) : null\n      );\n  }\n\n  getNextMutationBatchAfterBatchId(\n    transaction: PersistenceTransaction,\n    batchId: BatchId\n  ): PersistencePromise<MutationBatch | null> {\n    const range = IDBKeyRange.lowerBound(this.keyForBatchId(batchId + 1));\n    let foundBatch: MutationBatch | null = null;\n    return mutationsStore(transaction)\n      .iterate({ range }, (key, dbBatch, control) => {\n        if (dbBatch.userId === this.userId) {\n          assert(\n            dbBatch.batchId > batchId,\n            'Should have found mutation after ' + batchId\n          );\n          foundBatch = this.serializer.fromDbMutationBatch(dbBatch);\n        }\n        control.done();\n      })\n      .next(() => foundBatch);\n  }\n\n  getAllMutationBatches(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<MutationBatch[]> {\n    const range = IDBKeyRange.bound(\n      this.keyForBatchId(BATCHID_UNKNOWN),\n      this.keyForBatchId(Number.POSITIVE_INFINITY)\n    );\n    return mutationsStore(transaction)\n      .loadAll(range)\n      .next(dbBatches =>\n        dbBatches.map(dbBatch => this.serializer.fromDbMutationBatch(dbBatch))\n      );\n  }\n\n  getAllMutationBatchesThroughBatchId(\n    transaction: PersistenceTransaction,\n    batchId: BatchId\n  ): PersistencePromise<MutationBatch[]> {\n    const range = IDBKeyRange.bound(\n      this.keyForBatchId(BATCHID_UNKNOWN),\n      this.keyForBatchId(batchId)\n    );\n    return mutationsStore(transaction)\n      .loadAll(range)\n      .next(dbBatches =>\n        dbBatches.map(dbBatch => this.serializer.fromDbMutationBatch(dbBatch))\n      );\n  }\n\n  getAllMutationBatchesAffectingDocumentKey(\n    transaction: PersistenceTransaction,\n    documentKey: DocumentKey\n  ): PersistencePromise<MutationBatch[]> {\n    // Scan the document-mutation index starting with a prefix starting with\n    // the given documentKey.\n    const indexPrefix = DbDocumentMutation.prefixForPath(\n      this.userId,\n      documentKey.path\n    );\n    const indexStart = IDBKeyRange.lowerBound(indexPrefix);\n\n    const results: MutationBatch[] = [];\n    return documentMutationsStore(transaction)\n      .iterate({ range: indexStart }, (indexKey, _, control) => {\n        const [userID, encodedPath, batchID] = indexKey;\n\n        // Only consider rows matching exactly the specific key of\n        // interest. Note that because we order by path first, and we\n        // order terminators before path separators, we'll encounter all\n        // the index rows for documentKey contiguously. In particular, all\n        // the rows for documentKey will occur before any rows for\n        // documents nested in a subcollection beneath documentKey so we\n        // can stop as soon as we hit any such row.\n        const path = EncodedResourcePath.decode(encodedPath);\n        if (userID !== this.userId || !documentKey.path.equals(path)) {\n          control.done();\n          return;\n        }\n        const mutationKey = this.keyForBatchId(batchID);\n        // Look up the mutation batch in the store.\n        // PORTING NOTE: because iteration is callback driven in the web,\n        // we just look up the key instead of keeping an open iterator\n        // like iOS.\n        return mutationsStore(transaction)\n          .get(mutationKey)\n          .next(dbBatch => {\n            if (dbBatch === null) {\n              fail(\n                'Dangling document-mutation reference found: ' +\n                  indexKey +\n                  ' which points to ' +\n                  mutationKey\n              );\n            }\n            results.push(this.serializer.fromDbMutationBatch(dbBatch!));\n          });\n      })\n      .next(() => results);\n  }\n\n  getAllMutationBatchesAffectingQuery(\n    transaction: PersistenceTransaction,\n    query: Query\n  ): PersistencePromise<MutationBatch[]> {\n    assert(\n      !query.isDocumentQuery(),\n      \"Document queries shouldn't go down this path\"\n    );\n\n    const queryPath = query.path;\n    const immediateChildrenLength = queryPath.length + 1;\n\n    // TODO(mcg): Actually implement a single-collection query\n    //\n    // This is actually executing an ancestor query, traversing the whole\n    // subtree below the collection which can be horrifically inefficient for\n    // some structures. The right way to solve this is to implement the full\n    // value index, but that's not in the cards in the near future so this is\n    // the best we can do for the moment.\n    //\n    // Since we don't yet index the actual properties in the mutations, our\n    // current approach is to just return all mutation batches that affect\n    // documents in the collection being queried.\n    const indexPrefix = DbDocumentMutation.prefixForPath(\n      this.userId,\n      queryPath\n    );\n    const encodedQueryPath = indexPrefix[1];\n    const indexStart = IDBKeyRange.lowerBound(indexPrefix);\n\n    // Collect up unique batchIDs encountered during a scan of the index. Use a\n    // SortedSet to accumulate batch IDs so they can be traversed in order in a\n    // scan of the main table.\n    let uniqueBatchIDs = new SortedSet<BatchId>(primitiveComparator);\n    return documentMutationsStore(transaction)\n      .iterate({ range: indexStart }, (indexKey, _, control) => {\n        const [userID, encodedPath, batchID] = indexKey;\n        const path = EncodedResourcePath.decode(encodedPath);\n        if (userID !== this.userId || !queryPath.isPrefixOf(path)) {\n          control.done();\n          return;\n        }\n        // Rows with document keys more than one segment longer than the\n        // query path can't be matches. For example, a query on 'rooms'\n        // can't match the document /rooms/abc/messages/xyx.\n        // TODO(mcg): we'll need a different scanner when we implement\n        // ancestor queries.\n        if (path.length !== immediateChildrenLength) {\n          return;\n        }\n        uniqueBatchIDs = uniqueBatchIDs.add(batchID);\n      })\n      .next(() => {\n        const results: MutationBatch[] = [];\n        const promises: Array<PersistencePromise<void>> = [];\n        // TODO(rockwood): Implement this using iterate.\n        uniqueBatchIDs.forEach(batchID => {\n          const mutationKey = this.keyForBatchId(batchID);\n          promises.push(\n            mutationsStore(transaction)\n              .get(mutationKey)\n              .next(mutation => {\n                if (mutation === null) {\n                  fail(\n                    'Dangling document-mutation reference found, ' +\n                      'which points to ' +\n                      mutationKey\n                  );\n                }\n                results.push(this.serializer.fromDbMutationBatch(mutation!));\n              })\n          );\n        });\n        return PersistencePromise.waitFor(promises).next(() => results);\n      });\n  }\n\n  removeMutationBatches(\n    transaction: PersistenceTransaction,\n    batches: MutationBatch[]\n  ): PersistencePromise<void> {\n    const txn = mutationsStore(transaction);\n    const indexTxn = documentMutationsStore(transaction);\n    const promises: Array<PersistencePromise<void>> = [];\n\n    for (const batch of batches) {\n      const range = IDBKeyRange.only(this.keyForBatchId(batch.batchId));\n      let numDeleted = 0;\n      const removePromise = txn.iterate({ range }, (key, value, control) => {\n        numDeleted++;\n        return control.delete();\n      });\n      promises.push(\n        removePromise.next(() => {\n          assert(\n            numDeleted === 1,\n            'Dangling document-mutation reference found: Missing batch ' +\n              batch.batchId\n          );\n        })\n      );\n      for (const mutation of batch.mutations) {\n        const indexKey = DbDocumentMutation.key(\n          this.userId,\n          mutation.key.path,\n          batch.batchId\n        );\n        promises.push(indexTxn.delete(indexKey));\n        if (this.garbageCollector !== null) {\n          this.garbageCollector.addPotentialGarbageKey(mutation.key);\n        }\n      }\n    }\n    return PersistencePromise.waitFor(promises);\n  }\n\n  performConsistencyCheck(\n    txn: PersistenceTransaction\n  ): PersistencePromise<void> {\n    return this.checkEmpty(txn).next(empty => {\n      if (!empty) {\n        return PersistencePromise.resolve();\n      }\n\n      // Verify that there are no entries in the documentMutations index if\n      // the queue is empty.\n      const startRange = IDBKeyRange.lowerBound(\n        DbDocumentMutation.prefixForUser(this.userId)\n      );\n      const danglingMutationReferences: ResourcePath[] = [];\n      return documentMutationsStore(txn)\n        .iterate({ range: startRange }, (key, _, control) => {\n          const userID = key[0];\n          if (userID !== this.userId) {\n            control.done();\n            return;\n          } else {\n            const path = EncodedResourcePath.decode(key[1]);\n            danglingMutationReferences.push(path);\n          }\n        })\n        .next(() => {\n          assert(\n            danglingMutationReferences.length === 0,\n            'Document leak -- detected dangling mutation references when queue is empty. Dangling keys: ' +\n              danglingMutationReferences.map(p => p.canonicalString())\n          );\n        });\n    });\n  }\n\n  setGarbageCollector(gc: GarbageCollector | null): void {\n    this.garbageCollector = gc;\n  }\n\n  containsKey(\n    txn: PersistenceTransaction,\n    key: DocumentKey\n  ): PersistencePromise<boolean> {\n    const indexKey = DbDocumentMutation.prefixForPath(this.userId, key.path);\n    const encodedPath = indexKey[1];\n    const startRange = IDBKeyRange.lowerBound(indexKey);\n    let containsKey = false;\n    return documentMutationsStore(txn)\n      .iterate({ range: startRange, keysOnly: true }, (key, _, control) => {\n        const [userID, keyPath, batchID] = key;\n        if (userID === this.userId && keyPath === encodedPath) {\n          containsKey = true;\n        }\n        control.done();\n      })\n      .next(() => containsKey);\n  }\n\n  /**\n   * Creates a [userId, batchId] key for use with the DbMutationQueue object\n   * store.\n   */\n  private keyForBatchId(batchId: BatchId): DbMutationBatchKey {\n    return [this.userId, batchId];\n  }\n}\n\nfunction validateStreamToken(token: ProtoByteString): string {\n  assert(\n    typeof token === 'string',\n    'Persisting non-string stream token not supported.'\n  );\n  return token as string;\n}\n\n/**\n * Helper to get a typed SimpleDbStore for the mutations object store.\n */\nfunction mutationsStore(\n  txn: PersistenceTransaction\n): SimpleDbStore<DbMutationBatchKey, DbMutationBatch> {\n  return getStore<DbMutationBatchKey, DbMutationBatch>(\n    txn,\n    DbMutationBatch.store\n  );\n}\n\n/**\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\n */\nfunction documentMutationsStore(\n  txn: PersistenceTransaction\n): SimpleDbStore<DbDocumentMutationKey, DbDocumentMutation> {\n  return getStore<DbDocumentMutationKey, DbDocumentMutation>(\n    txn,\n    DbDocumentMutation.store\n  );\n}\n\n/**\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\n */\nfunction mutationQueuesStore(\n  txn: PersistenceTransaction\n): SimpleDbStore<DbMutationQueueKey, DbMutationQueue> {\n  return getStore<DbMutationQueueKey, DbMutationQueue>(\n    txn,\n    DbMutationQueue.store\n  );\n}\n\n/**\n * Helper to get a typed SimpleDbStore from a transaction.\n */\nfunction getStore<KeyType extends IDBValidKey, ValueType>(\n  txn: PersistenceTransaction,\n  store: string\n): SimpleDbStore<KeyType, ValueType> {\n  if (txn instanceof SimpleDbTransaction) {\n    return txn.store<KeyType, ValueType>(store);\n  } else {\n    return fail('Invalid transaction object provided!');\n  }\n}\n"]}